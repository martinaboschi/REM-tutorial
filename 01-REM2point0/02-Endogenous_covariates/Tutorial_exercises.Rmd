---
title: "Relational Event Models 2.0"
author: "Bianchi, Federica;  Boschi, Martina"
date: "2024-06-24"
output:
  pdf_document: default
  html_notebook: default
subtitle: "Endogenous Covariates - Tutorial Section: Solution"
header-includes:  
- \usepackage{xcolor}  
- \definecolor{persianred}{rgb}{0.8, 0.2, 0.2}
- \definecolor{persianred}{rgb}{0.8, 0.2, 0.2}
- \definecolor{pastelyellow}{rgb}{0.99, 0.99, 0.59}
- \definecolor{pastelpurple}{rgb}{0.7, 0.62, 0.71}
- \definecolor{cerulean}{rgb}{0.0, 0.48, 0.65}
- \definecolor{darkseagreen}{rgb}{0.56, 0.74, 0.56}
- \definecolor{mauvetaupe}{rgb}{0.57, 0.37, 0.43}
---

```{r setup, include=FALSE}
knitr::knit_hooks$set(purl = knitr::hook_purl)
knitr::opts_chunk$set(echo = TRUE)
```

# Endogenous Covariates: Application to Alien Species Invasions

## 0.   Preparatory Steps: Introducing Alien Species Invasions

### 0.1.    Installing libraries

\emph{In the following section, we will install the necessary packages for this tutorial. The provided code ensures that the packages are installed only if they are not already present on your system.}

```{r message=FALSE, warning=FALSE}
if (!require("mgcv", quietly = TRUE)) {
  # If not installed, install it
  install.packages("mgcv")
  # Load the package
  library("mgcv")
} else {
  if (!require("splines", quietly = TRUE)) {
    install.packages("splines")
    library("splines")
  } else {
    if (!require("ggplot2", quietly = TRUE)) {
      install.packages("ggplot2")
      library("ggplot2")
    } else {
      if (!require("tidyverse", quietly = TRUE)) {
        install.packages("tidyverse")
        library("tidyverse")
      } else {
        if (!require("RColorBrewer", quietly = TRUE)){
          install.packages("RColorBrewer")
        } else {
          if (!require("mgcViz", quietly = TRUE)){
            install.packages("mgcViz")
          } else {
            library("mgcv")
            library("splines")
            library("ggplot2")
            library("tidyverse")
            library("RColorBrewer")
            library("mgcViz")
          }
        }
      }
    }
  }
}
```

\emph{During the tutorial, we will refer to the following color palettes to improve the visualization of the results.}

```{r}
pal.blue <- brewer.pal(9, "Blues")
pal.rose <- brewer.pal(9, "RdPu")
colors <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2",
            "#D55E00", "#CC79A7", "#999999", "#66C2A5", "#FC8D62")
```


## 1.   Exogenous \& Endogenous: An introductory example on Popularity

```{r, echo=FALSE}
knitr::include_graphics("02-Images/class-network.pdf")
```

\colorbox{darkseagreen}{Demo 1}: 

\colorbox{darkseagreen}{D1.1}: Load the input data \textcolor{persianred}{"input01.RData"}.

```{r}
load("01-Data/01-Inputs/input01.RData")
```

```{r}
head(dat.gam)
```

\colorbox{darkseagreen}{D1.2}: Incorporate the \textcolor{mauvetaupe}{exogenous information} concerning the \textcolor{cerulean}{role} of the receiver involved in the event. Compute the covariate in the events, in the non-events and the relative difference.

```{r}
receiver.teacher <- class$info$teacher[dat.gam$receiver] 
non.receiver.teacher <- class$info$teacher[dat.gam$non.receiver]
receiver.teacher.diff <- receiver.teacher - non.receiver.teacher
dat.gam <- cbind(dat.gam,
                 receiver.teacher,non.receiver.teacher,
                 receiver.teacher.diff, y=1)
```

\emph{REMARK: To exploit case-control partial likelihood via GAMs, we need to include in the data a fixed variable equal to 1} `y` \emph{that serves as the response for our model}.

\colorbox{darkseagreen}{D1.3}: Incorporate the \textcolor{mauvetaupe}{exogenous information} concerning the \textcolor{cerulean}{role} of the receiver involved in the event. Compute the covariate in the events, in the non-events and the relative difference.

```{r}
summary(gam(y ~ receiver.teacher.diff - 1, 
            data=dat.gam, 
            family="binomial"))
```

\colorbox{darkseagreen}{D1.4}: Compute the \textcolor{mauvetaupe}{popularity network statistics} for the first $6$ events, without using functions. 

```{r}
head(dat.gam)
```

\colorbox{darkseagreen}{D1.5}: Write a function `receiver_popularity` that, given the case-control dataset and the ordinal position of the event in the time sequence, computes the number of previously occurred interactions with the same receiver as the event or the non-event (according to the optional parameter `ev=TRUE`). Apply the function to the events and the sampled non-events and compute the difference.

```{r}
receiver_popularity <- function(dat.gam, k, ev=TRUE) {
  
  # Check if k is within bounds
  if (k < 1 || k > nrow(dat.gam)) {
    stop("k is out of bounds.")
  }
  
  # If k is 1, there's no history to compare, return 0
  if (k == 1) {
    return(0)
  } else {
    
    # Calculate the history of receivers up to the (k-1)th element
    history_receiver <- dat.gam$receiver[1:(k-1)]
    
    # Ensure that dat.gam has the required columns
    if (!"receiver" %in% names(dat.gam)) {
      stop("dat.gam does not contain the column 'receiver'.")
    }
    if (!"non.receiver" %in% names(dat.gam) && !ev) {
      stop("dat.gam does not contain the column 'non.receiver'.")
    }
    
    # Calculate popularity based on the value of ev
    if (ev) {
      return(sum(history_receiver == dat.gam$receiver[k]))
    } else {
      return(sum(history_receiver == dat.gam$non.receiver[k]))
    }
  }
}

```

```{r}
dat.gam$endPop1 <- sapply(1:nrow(dat.gam), 
                          function(x) receiver_popularity(dat.gam, x, ev=TRUE))
dat.gam$endPop2 <- sapply(1:nrow(dat.gam), 
                          function(x) receiver_popularity(dat.gam, x, ev=FALSE))
endPop_diff = dat.gam$endPop1 - dat.gam$endPop2
```

\colorbox{darkseagreen}{D1.6}: Fit a linear model with `endPop_diff` only. Is this covariate significant? Interpret the results. 

```{r}
summary(gam(y ~ endPop_diff - 1, 
            data=dat.gam, 
            family="binomial"))
```

## 2.   Towards the computaion of endogenous dyadic and triadic covariates

### 2.1.    Reciprocity and Cyclic Closure

\colorbox{darkseagreen}{Demo 2}:

\colorbox{darkseagreen}{D2.1}: Write a function `rec_cyc` that, given the case-control dataset and the ordinal position of the event in the time sequence, computes two indicators for  \textcolor{mauvetaupe}{Reciprocity} and  \textcolor{mauvetaupe}{Cyclic Closure}. The function should have an optional parameter `ev=TRUE` to determine which columns to use for event's sender and receiver information. Apply the function to the events and the sampled non-events, then compute the difference between these two indicators for events and non-events.

```{r}
rec_cyc <- function(dat.gam, k, ev=TRUE) {
  
  # Determine which column indices to use based on the 'ev' flag
  if (ev) {
    s <- dat.gam[k, 2]   # 's' is the second column (event sender)
    r <- dat.gam[k, 3]   # 'r' is the third column (event receiver)
  } else {
    s <- dat.gam[k, 4]   # 's' is the fourth column (event sender)
    r <- dat.gam[k, 5]   # 'r' is the fifth column (event receiver)
  }
  
  # Check if k is within bounds of dat.gam
  if (k < 1 || k > nrow(dat.gam)) {
    stop("k is out of bounds.")
  }
  
  # If k is 1, there's no history to compare, return (0, 0)
  if (k == 1) {
    return(c(0, 0))
  } else {
    # Initialize variables to store reciprocity and cyclic closure indicators
    rec_id <- 0
    cyc_id <- 0
    
    # Determine the starting point in the past to begin examining
    prev <- which(dat.gam[1:(k-1), 2] == s & dat.gam[1:(k-1), 3] == r)
    if (length(prev) > 0) {
      prev <- prev[length(prev)] + 1
    } else {
      prev <- 1
    }
    
    # Check if there are third parties interacting towards 's'
    t <- which(dat.gam[prev:k, 3] == s)
    t <- prev + t - 1
    l <- dat.gam[t, 2]
    common.nodes <- unique(l)
    
    if (length(common.nodes) != 0) {
      # Iterate over each common node 'a'
      for (a in common.nodes) {
        
        # Check if 'a' is the receiver 'r' (reciprocity check)
        if (a == r) {
          rec_id <- max(rec_id, 1)
        } else {
          # Find the latest time 'a' interacted towards 's'
          stop_t <- dat.gam$time[t[which(dat.gam[t, 2] == a & 
                                         dat.gam[t, 3] == s)]]
          stop_t <- max(stop_t)
          
          # Check if 'r' interacted towards 'a' before 'stop_t'
          t2 <- which(dat.gam[prev:max(which(dat.gam$time == stop_t)), 2] == r &
                      dat.gam[prev:max(which(dat.gam$time == stop_t)), 3] == a)
          
          # If at least one such event is found, set cyclic closure indicator
          if (length(t2) > 0) {
            cyc_id <- max(cyc_id, 1)
          } else {
            # Check if 'r' interacted towards 'a' before 's' interacted towards 'r'
            t3 <- which(dat.gam[1:prev, 2] == r & dat.gam[1:prev, 3] == a)
            if (length(t3) > 0) {
              cyc_id <- max(cyc_id, 1)
            }
          }
        }
      }
    }
  }
  
  # Return the reciprocity and cyclic closure indicators
  return(c(rec_id, cyc_id))
}
```

```{r}
events <- t(sapply(1:nrow(dat.gam), 
                 function(x) rec_cyc(dat.gam, x, ev=TRUE)))
non_events <- t(sapply(1:nrow(dat.gam), 
                function(x) rec_cyc(dat.gam, x, ev=FALSE)))

dat.gam <- cbind(dat.gam, 
                 rec1 = events[,1],
                 cyc1 = events[,2],
                 rec2 = non_events[,1],
                 cyc2 = non_events[,2])
dat.gam$rec_diff = dat.gam$rec1 - dat.gam$rec2
dat.gam$cyc_diff = dat.gam$cyc1 - dat.gam$cyc2
```

\colorbox{darkseagreen}{D2.2}: Check the function \texttt{n\_effects} uploaded with the input data. Apply the function to the data concerning events and non-events. Which columns of the output correspond to the reciprocity you computed in \colorbox{darkseagreen}{D2.1}?

REMARK! Attention to the order of the columns of the dataset!

```{r}
events_alt <- n_effects(dat.gam[,c(2,3,1)], dat.gam[,c(4,5,1)])[[1]]
non_events_alt <- n_effects(dat.gam[,c(2,3,1)], dat.gam[,c(4,5,1)])[[2]]
```

```{r}
# events_alt$r1==dat.gam$rec1
```

```{r}
# non_events_alt$r1==dat.gam$rec2
```

\colorbox{darkseagreen}{D2.3}: Fit a linear model with \texttt{endPop\_diff} and \texttt{rec\_diff}. What happens to \texttt{endPop\_diff}? Interpret the results.

```{r}
summary(gam(y ~ endPop_diff + rec_diff - 1, data=dat.gam, 
            family="binomial"))
```

\colorbox{darkseagreen}{D2.4}: Add \texttt{cyc\_diff} to the fitting. Interpret the results. 

```{r}
summary(gam(y ~ endPop_diff + rec_diff + cyc_diff - 1, data=dat.gam, 
            family="binomial"))
```

\emph{Cyclic closure is tested as significant in this model formulation.}

### 2.2.    Transitive Closure

\colorbox{darkseagreen}{Demo 3}: 

\colorbox{darkseagreen}{D3.1}: Write a function \texttt{transitive\_closure} that, given the case-control dataset and the ordinal position, computes an indicator for  \textcolor{mauvetaupe}{Transitive Closure} in the \textcolor{mauvetaupe}{short and long term}. The function should have a parameter \texttt{alpha} determining short and long term and an optional parameter \texttt{ev=TRUE}. The \textcolor{mauvetaupe}{event of interest} is represented (in this case) by the (second-leg) of the triangle $a \rightarrow r$.

```{r}
transitive_closure_slt <- function(dat.gam, k, alpha, ev=TRUE) {
  
  current <- as.numeric(dat.gam[k, 1])
  
  # Determine which column indices to use based on the 'ev' flag
  if (ev) {
    s <- dat.gam[k, 2]   # 's' is the second column (event sender)
    r <- dat.gam[k, 3]   # 'r' is the third column (event receiver)
  } else {
    s <- dat.gam[k, 4]   # 's' is the fourth column (event sender)
    r <- dat.gam[k, 5]   # 'r' is the fifth column (event receiver)
  }
  
  # Check if k is within bounds of dat.gam
  if (k < 1 || k > nrow(dat.gam)) {
    stop("k is out of bounds.")
  }
  
  # If k is 1, there's no history to compare, return (0, 0)
  if (k == 1) {
    return(c(0, 0, 0))
  } else {
    
    # Determine the starting point in the past to begin examining
    prev <- which(dat.gam[1:(k-1), 2] == s & dat.gam[1:(k-1), 3] == r)
    if (length(prev) > 0) {
      prev <- prev[length(prev)] + 1
    } else {
      prev <- 1
    }
    
    trs_rec <- trs_long <- trs_id <- 0
    
    # Check if there are third parties interacting towards 'r'
    t <- which(dat.gam[prev:k,3]==r)
    t <- prev + t - 1
    l <- dat.gam[t,2]
    common.nodes <- unique(l)
    
    if(length(common.nodes)!=0){
      
      # Iterate over each common node 'a'
      for(a in common.nodes){
      
      # Find the latest time 'a' interacted towards 'r'
      stop_t <- dat.gam$time[t[which(dat.gam[t,2]==a & dat.gam[t,3] == r)]]
      stop_t <- max(stop_t)
      
      # Check if 's' interacted towards 'a' before 'stop_t'
      t2 <- which(dat.gam[prev:max(which(dat.gam$time==stop_t)),2]==s &
                  dat.gam[prev:max(which(dat.gam$time==stop_t)),3]==a)
      
      # If at least one such event is found, 
      # check if latest time 'a' interacted towards 'r' 
      # is larger or smaller than (current-alpha)
      if (length(t2)>0){
        if (stop_t>=(current-alpha)){
          trs_rec <- max(trs_rec,1)
        } else {
          trs_long <- max(trs_long, 1)
        }
        trs_id <- max(trs_id, 1)
      } else {
        
        # Check if 's' interacted towards 'a' before 's' interacted towards 'r'
        t3 <- which(dat.gam[1:prev,2]==s & dat.gam[1:prev,3]==a)
        if (length(t3) > 0) {
          if (stop_t>=(current-alpha)){
            trs_rec <- max(trs_rec,1)
            } else {
              trs_long <- max(trs_long, 1)
              }
          trs_id <- max(trs_id, 1)
        }
      }
      }
    }
  }
  
  return(c(trs_rec, trs_long, trs_id))
}
```

\colorbox{darkseagreen}{D3.2}:  Apply the function \texttt{transitive\_closure} to `Class` events and sampled non-events, then compute the difference between obtained indicators for events and non-events (in the short and long term). Add them to the model in \colorbox{darkseagreen}{D2.4}.

```{r}
events <- t(sapply(1:nrow(dat.gam), 
                 function(x) transitive_closure_slt(dat.gam, x, alpha = 10, ev=TRUE)))
non_events <- t(sapply(1:nrow(dat.gam), 
                function(x) transitive_closure_slt(dat.gam, x, alpha = 10, ev=FALSE)))

dat.gam <- cbind(dat.gam, 
                 trs_rec1 = events[,3],
                 trs_rec2 = non_events[,3])
dat.gam$trs_rec = dat.gam$trs_rec1 - dat.gam$trs_rec2
```

```{r}
summary(gam(y ~ endPop_diff + rec_diff + cyc_diff + 
            trs_rec - 1, data=dat.gam, 
            family="binomial"))
```

## 3.   Time in REMs Network Statistics: Short VS Long-Term Network Statistics

\colorbox{darkseagreen}{Demo 4}: 

```{r, echo=FALSE}
knitr::include_graphics("02-Images/timeline.pdf")
```

\colorbox{darkseagreen}{Demo 4.1}: Consider the following sequence of $20$ to exercise with the network statistics computation. You find the data in \textcolor{persianred}{input02.RData}.

```{r}
# rem_dat <- matrix(c(1, "A", "B", 2, "A", "B",
#                     3, "A", "B", 4, "B", "A",
#                     5, "A", "B", 6, "B", "C",
#                     7, "C", "B", 8, "B", "A",
#                     9, "A", "C", 10, "C", "A",
#                     11, "C", "B", 12, "A", "B",
#                     13, "A", "B", 14, "A", "B",
#                     15, "B", "C", 16, "A", "B",
#                     17, "A", "C", 18, "C", "B",
#                     19, "B", "C", 20, "A", "B"),
#                   ncol=3, byrow=TRUE)
# colnames(rem_dat) <- c("time", "sender", "receiver")
# rem_dat <- data.frame(rem_dat)
# rem_dat$time <- as.numeric(rem_dat$time)
```

```{r}
# save.image(file="input02.RData")
```

```{r}
load(file="01-Data/01-Inputs/input02.RData")
```

\colorbox{darkseagreen}{Demo 4.2}: Modify the function `rec_cyc`, creating the function `rec_cyc_slt` that, given the case-control dataset and the ordinal position of the event in the time sequence, computes  indicators for  \textcolor{mauvetaupe}{Reciprocity} and  \textcolor{mauvetaupe}{Cyclic Closure}, considering their presence in general (as before), and in the \textcolor{mauvetaupe}{short and long term}. The function should have a parameter \texttt{alpha} determining short and long term and an optional parameter \texttt{ev=TRUE}. The \textcolor{mauvetaupe}{event of interest} is represented (in this case) by the reciprocal event for reciprocoty and the (second-leg) of the triangle $a \rightarrow s$. The function should have an optional parameter `ev=TRUE`.

```{r}
rec_cyc_slt <- function(dat.gam, k, alpha, ev=TRUE) {
  
  current <- as.numeric(dat.gam[k, 1])
  
  # Determine which column indices to use based on the 'ev' flag
  if (ev) {
    s <- dat.gam[k, 2]   # 's' is the second column (event sender)
    r <- dat.gam[k, 3]   # 'r' is the third column (event receiver)
  } else {
    s <- dat.gam[k, 4]   # 's' is the fourth column (event sender)
    r <- dat.gam[k, 5]   # 'r' is the fifth column (event receiver)
  }
  
  # Check if k is within bounds of dat.gam
  if (k < 1 || k > nrow(dat.gam)) {
    stop("k is out of bounds.")
  }
  
  # If k is 1, there's no history to compare, return (0, 0)
  if (k == 1) {
    return(c(0, 0, 0, 0, 0, 0))
  } else {
    # Initialize variables to store reciprocity and cyclic closure indicators
    rec_rec <- rec_long <- rec_id <- 0
    cyc_rec <- cyc_long <- cyc_id <- 0
    
    # Determine the starting point in the past to begin examining
    prev <- which(dat.gam[1:(k-1), 2] == s & dat.gam[1:(k-1), 3] == r)
    if (length(prev) > 0) {
      prev <- prev[length(prev)] + 1
    } else {
      prev <- 1
    }
    
    # Check if there are third parties interacting towards 's'
    t <- which(dat.gam[prev:k, 3] == s)
    t <- prev + t - 1
    l <- dat.gam[t, 2]
    common.nodes <- unique(l)
    
    if (length(common.nodes) != 0) {
      # Iterate over each common node 'a'
      for (a in common.nodes) {
        
        # Check if 'a' is the receiver 'r' (reciprocity check)
        if (a == r) {
          stop_t <- dat.gam$time[t[which(dat.gam[t, 2] == r & 
                                         dat.gam[t, 3] == s)]]
          stop_t <- max(stop_t)
          if (stop_t>=(current-alpha)){
            rec_rec <- max(rec_rec,1)
            } else {
            rec_long <- max(rec_long, 1)
          }
          rec_id <- max(rec_id, 1)
        } else {
          # Find the latest time 'a' interacted towards 's'
          stop_t <- dat.gam$time[t[which(dat.gam[t, 2] == a & 
                                         dat.gam[t, 3] == s)]]
          stop_t <- max(stop_t)
          
          # Check if 'r' interacted towards 'a' before 'stop_t'
          t2 <- which(dat.gam[prev:max(which(dat.gam$time == stop_t)), 2] == r &
                      dat.gam[prev:max(which(dat.gam$time == stop_t)), 3] == a)
          
          # If at least one such event is found, set cyclic closure indicator
          if (length(t2) > 0) {
            if (stop_t>=(current-alpha)){
              cyc_rec <- max(cyc_rec,1)
            } else {
              cyc_long <- max(cyc_long, 1)
            }
            cyc_id <- max(cyc_id, 1)
          } else {
            # Check if 'r' interacted towards 'a' before 's' interacted towards 'r'
            t3 <- which(dat.gam[1:prev, 2] == r & dat.gam[1:prev, 3] == a)
            if (length(t3) > 0) {
              if (stop_t>=(current-alpha)){
                cyc_rec <- max(cyc_rec,1)
              } else {
                cyc_long <- max(cyc_long, 1)
              }
              cyc_id <- max(cyc_id, 1)
            }
          }
        }
      }
    }
  }
  
  # Return the reciprocity and cyclic closure indicators
  return_object <- c(rec_rec, rec_long, rec_id, cyc_rec, cyc_long, cyc_id)
  names(return_object) <- c("rec_short", 
                            "rec_long",
                            "rec_id",
                            "cyc_short",
                            "cyc_long",
                            "cyc_id")
  return(return_object)
}
```

\colorbox{pastelyellow}{Exercise 1}: 

\colorbox{pastelyellow}{E1.1}: Apply `rec_cyc_slt` to the event sequence. Find the value of `alpha` that allows to find the following dynamics: 

```{r}
knitr::include_graphics("02-Images/dynamics-simulated.pdf")
```

```{r}
frame_1 <- t(sapply(1:20, function(x) rec_cyc_slt(dat.gam = rem_dat, k=x,
                                      alpha = 3)))
colnames(frame_1) <- c("rec_short", 
                       "rec_long",
                       "rec_id",
                       "cyc_short",
                       "cyc_long",
                       "cyc_id")
frame_1
```

\colorbox{pastelyellow}{E1.2}: Apply `transitive_closure_slt` to the event sequence with the found value for `alpha`. 

```{r}
frame_2 <- t(sapply(1:20, function(x) transitive_closure_slt(dat.gam = rem_dat, k=x,
                                      alpha = 3)))
colnames(frame_2) <- c("trs_short", "trs_long", "trs_id")
frame_2
```

\colorbox{pastelyellow}{E1.3}: Plot the obtained structures.  

```{r, echo=FALSE}
knitr::include_graphics("02-Images/solution-exercise1.pdf")
```

\colorbox{pastelyellow}{E1.4}: Create the case-control dataset (namely, sample a non-event for each event, compute the covariates for the non-events and then the difference between the covariates of the events and those of the non-events)

```{r}
combos <- expand.grid(c("A", "B", "C"), c("A", "B", "C"))
pairs <- subset(combos, Var1 != Var2)
set.seed(2)
non_rem_dat <- pairs[sample(1:nrow(pairs), 20, replace=TRUE), ]
non_rem_dat <- cbind(non_rem_dat,
                     t(sapply(1:20, function(x) 
                       rec_cyc_slt(dat.gam = non_rem_dat, 
                                   k=x, alpha = 3))),
                     t(sapply(1:20, function(x) 
                       transitive_closure_slt(dat.gam = rem_dat, 
                                              k=x, alpha = 3))))
colnames(non_rem_dat) <- c("non.sender", 
                           "non.receiver",
                           "non.rec_short", 
                           "non.rec_long",
                           "non.rec_id",
                           "non.cyc_short",
                           "non.cyc_long",
                           "non.cyc_id",
                           "non.trs_short", 
                           "non.trs_long", 
                           "non.trs_id")
```

```{r}
rem_dat <- cbind(rem_dat, frame_1)
rem_dat <- cbind(rem_dat, frame_2)
rem_dat <- cbind(rem_dat, non_rem_dat)
rem_dat <- cbind(rem_dat, 1)
colnames(rem_dat)[ncol(rem_dat)] <- "y"
rem_dat[,c("diff.rec_short", 
           "diff.rec_long",
           "diff.rec_id",
           "diff.cyc_short",
           "diff.cyc_long",
           "diff.cyc_id",
           "diff.trs_short",
           "diff.trs_long", 
           "diff.trs_id")] <- 
rem_dat[,c("rec_short", 
           "rec_long",
           "rec_id",
           "cyc_short",
           "cyc_long",
           "cyc_id",
           "trs_short",
           "trs_long", 
           "trs_id")] -
  rem_dat[,c("non.rec_short", 
           "non.rec_long",
           "non.rec_id",
           "non.cyc_short",
           "non.cyc_long",
           "non.cyc_id",
           "non.trs_short",
           "non.trs_long", 
           "non.trs_id")]
```

\colorbox{pastelyellow}{E1.5}: Fit a GAM exploring the effect of reciprocity on the long and short term. 

```{r}
summary(gam(y ~ diff.rec_short + diff.rec_long - 1,
            data=rem_dat, 
            family="binomial"))
```

## 4.   Time to work on real data... Inspecting a financial market!

```{r, echo=FALSE}
knitr::include_graphics("02-Images/exo-endo.pdf")
```

### 4.1. Background

\emph{The interbank market is a vital component of the financial system, connecting banks and other financial institutions to borrow and lend cash equivalent assets from each other. This allows banks to manage their liquidity needs and ensure they have sufficient funds to meet customer demands. In Europe, a significant portion of this interbank activity used to take place on a platform called e-MID, which ceased its activity in 2019 after 21 years of service.}

### 4.2. Covariate Computation

\emph{The computation of network statistics in performed in Java, according to the following setting:}

-   \emph{Recency window, corresponding with the short-term, is set equal to 45 days through the withinDays parameter.}
-   \emph{The exponential weight for time-weighted statistics is set equal to 0.6. It has been obtained via grid search and minimize the BIC.}

In the theoretical section we did express the short/long term covariates as follows: 

$$x^{1, \text{short}, \ldots}_{sr}(t; \alpha) = 1\{ t_i < t: t_i \text{ meeting conditions} \ldots , t_i \ge (t-\alpha) \}$$

$$x^{1, \text{long}, \ldots}_{sr}(t; \alpha) = 1\{ t_i < t: t_i \text{ meeting conditions} \ldots , t_i < (t-\alpha) \}$$

\emph{Nevertheless, it is possible to consider a decay function to account for the passage of time in the long term.}

$$ x^{\mathbb{W}, \text{long}, \ldots}_{sr}(t; \alpha, \delta) =  
1\{ t_i < t: t_i \text{ meeting conditions} \ldots , t_i < (t-\alpha) \} \times \frac{1}{\left(t - t_i \right)^{\beta}} $$

-   \emph{Start and end dates represent the period of observation. Dates are transformed into integers by counting the number of days from 1970-01-01}.

### 4.3. Model Estimation

We will consider a baseline model (M) and will add more refined network statistics. More specifically:

- \emph{M includes statistics computed over the whole observation period;}
- \emph{M\_TW include *time-weighted* network statistics}.

\colorbox{darkseagreen}{Demo 5}: 

\colorbox{darkseagreen}{Demo 5.1}: Load the data in \textcolor{persianred}{input03.RData}.

```{r}
load("01-Data/01-Inputs/input03.RData")
```

\colorbox{darkseagreen}{Demo 5.2}: In examining the case-control dataset, what specific information indicates that a \textcolor{mauvetaupe}{stratified model} will be used?

#### 4.3.1. Baseline Model

\colorbox{darkseagreen}{D5.3}: Fit the \textcolor{mauvetaupe}{baseline model}, including nodal, diadic, and extra-diadic statistics. 

```{r}
M = gam(one ~ ## OUT-DEGREE + OUT-ACTIVITY + IN-DEGREE + IN-ACTIVITY
          RecOutDeg + RecNROutAct + RecInDeg + RecNRInAct +
          ## NODE BALANCE
          RecNetBal +
          ## TIME FROM LAST EVENT
          RecLastTime +
          ## ASSORTATIVITY BY DEGREE AND BY INTENSITY
          SdrOutDeg_RecInDeg + SdrNROutAct_RecNRInAct +
          ## REPETITION AND RECIPROCITY
          EdTrt + EdRec +
          ## DYADIC BALANCE
          EdBalDif + 
          ## TRANSITIVE CLOSURE + CYCLIC CLOSURE + SHARED LENDERS + SHARED BORROWERS
          EdTran + EdClos + EdShrBors + EdShrLens - 1,

        data=dat.gam, 
        family="binomial")
```

```{r}
# save(M, file="01-Data/02-Gam-Fits/baseline-model.RData")
summary(M)
```

\colorbox{darkseagreen}{D5.4}: Incorporate in the model \textcolor{mauvetaupe}{time-weighted network statistics}.

```{r}
M_TW = gam(one ~  
             ## OUT-DEGREE + OUT-ACTIVITY + IN-DEGREE + IN-ACTIVITY
             RecOutDeg + RecNROutAct + RecInDeg + RecNRInAct +
             ## NODE BALANCE
             RecNetBal +
             ## TIME FROM LAST EVENT
             RecLastTime +
             ## ASSORTATIVITY BY DEGREE AND BY INTENSITY
             SdrOutDeg_RecInDeg + SdrNROutAct_RecNRInAct +
             ## REPETITION AND RECIPROCITY
             EdTWTrt + EdTWRec +
             ## DYADIC BALANCE
             EdBalDif + 
             ## TRANSITIVE CLOSURE + CYCLIC CLOSURE + SHARED BORROWERS + SHARED LENDERS
             EdTWTran + EdTWClos + EdTWShrBors + EdShrLens -1,

           family = "binomial", 
           data = dat.gam)
```

```{r}
# save(M_TW, file="01-Data/02-Gam-Fits/time-weighted-model.RData")
summary(M_TW)
```

#### 4.3.3. Model Comparison

 \colorbox{darkseagreen}{D5.5}: Compare the two models above using AIC or BIC. 
 
```{r}
save.image("01-Data/03-Output/output.RData")
```
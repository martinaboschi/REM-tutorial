---
title: "Relational Event Models 2.0"
author: "Bianchi, Federica;  Boschi, Martina"
date: "2024-06-24"
output:
  pdf_document: default
  html_notebook: default
subtitle: "Endogenous Covariates - Tutorial Section: Solution"
header-includes:  
- \usepackage{xcolor}  
- \definecolor{persianred}{rgb}{0.8, 0.2, 0.2}
- \definecolor{persianred}{rgb}{0.8, 0.2, 0.2}
- \definecolor{pastelyellow}{rgb}{0.99, 0.99, 0.59}
- \definecolor{pastelpurple}{rgb}{0.7, 0.62, 0.71}
- \definecolor{cerulean}{rgb}{0.0, 0.48, 0.65}
- \definecolor{darkseagreen}{rgb}{0.56, 0.74, 0.56}
- \definecolor{mauvetaupe}{rgb}{0.57, 0.37, 0.43}
---

```{r setup, include=FALSE}
knitr::knit_hooks$set(purl = knitr::hook_purl)
knitr::opts_chunk$set(echo = TRUE)
```

# Endogenous Covariates: Application to Alien Species Invasions

## 0.   Preparatory Steps: Introducing Alien Species Invasions

### 0.1.    Installing libraries

\emph{In the following section, we will install the necessary packages for this tutorial. The provided code ensures that the packages are installed only if they are not already present on your system.}

```{r message=FALSE, warning=FALSE}
if (!require("mgcv", quietly = TRUE)) {
  # If not installed, install it
  install.packages("mgcv")
  # Load the package
  library("mgcv")
} else {
  if (!require("splines", quietly = TRUE)) {
    install.packages("splines")
    library("splines")
  } else {
    if (!require("ggplot2", quietly = TRUE)) {
      install.packages("ggplot2")
      library("ggplot2")
    } else {
      if (!require("tidyverse", quietly = TRUE)) {
        install.packages("tidyverse")
        library("tidyverse")
      } else {
        if (!require("RColorBrewer", quietly = TRUE)){
          install.packages("RColorBrewer")
        } else {
          if (!require("mgcViz", quietly = TRUE)){
            install.packages("mgcViz")
          } else {
            library("mgcv")
            library("splines")
            library("ggplot2")
            library("tidyverse")
            library("RColorBrewer")
            library("mgcViz")
          }
        }
      }
    }
  }
}
```

\emph{During the tutorial, we will refer to the following color palettes to improve the visualization of the results.}

```{r}
pal.blue <- brewer.pal(9, "Blues")
pal.rose <- brewer.pal(9, "RdPu")
colors <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2",
            "#D55E00", "#CC79A7", "#999999", "#66C2A5", "#FC8D62")
```


## 1.   Exogenous \& Endogenous: An introductory example on Popularity

```{r, echo=FALSE}
knitr::include_graphics("02-Images/class-network.pdf")
```

\colorbox{darkseagreen}{Demo 1}: 

\colorbox{darkseagreen}{D1.1}: Load the input data \textcolor{persianred}{"input01.RData"}.

```{r}
load("01-Data/01-Inputs/input01.RData")
```

\emph{Data for this exercise are based on streaming interaction data collected by Daniel McFarland on students in classrooms. Time-stamped interactions in each classroom were recorded, with information on the \textcolor{mauvetaupe}{sender} and \textcolor{mauvetaupe}{receiver} of the interaction, as well as the nature of the interaction. Interactions could be social or task-based, for example, although we focus just on social interactions in this tutorial. We focus on the interactions that were recorded during one class hour in classroom 182.}

\emph{There are $n=279$ interactions between 17 predominantly female students and 1 male, black teacher. There is an even proportion of white and black students in the room.}

\emph{In this context we employ the same \textcolor{mauvetaupe}{case-control data set} contained in object} `dat.gam` {that has been used in the first Section. For each event there is thus one non-event sampled from the risk set at that time}.

```{r}
head(dat.gam)
```

\colorbox{darkseagreen}{D1.2}: Incorporate the \textcolor{mauvetaupe}{exogenous information} concerning the \textcolor{cerulean}{role} of the receiver involved in the event. Compute the covariate in the events, in the non-events and the relative difference.

```{r}
receiver.teacher <- class$info$teacher[dat.gam$receiver] 
non.receiver.teacher <- class$info$teacher[dat.gam$non.receiver]
receiver.teacher.diff <- receiver.teacher - non.receiver.teacher
dat.gam <- cbind(dat.gam,
                 receiver.teacher,non.receiver.teacher,
                 receiver.teacher.diff, y=1)
```

\emph{REMARK: To exploit case-control partial likelihood via GAMs, we need to include in the data a fixed variable equal to 1} `y` \emph{that serves as the response for our model}.

\colorbox{darkseagreen}{D1.3}: Incorporate the \textcolor{mauvetaupe}{exogenous information} concerning the \textcolor{cerulean}{role} of the receiver involved in the event. Compute the covariate in the events, in the non-events and the relative difference.

```{r}
summary(gam(y ~ receiver.teacher.diff - 1, 
            data=dat.gam, 
            family="binomial"))
```

\colorbox{darkseagreen}{D1.4}: Compute the \textcolor{mauvetaupe}{popularity network statistics} for the first $6$ events, without using functions. 

\emph{First at all, covariates must be predictable and measurable at time $t$, namely they depend on the previous history of events. This means that given an event $(s,r,t)$, we need to look back to events occurred before time $t$.} 

\emph{Once we identified events occurred in the time-window of interest, we can count the ones satisfying the condition of interest. For example, in this case, given $(s,r,t)$, we aim at finding all the previous events with receiver equal to $r$.}

$$ x_{r}^{\text{in-degree}}(t) =  \sum_{t_i < t} {1} \{ r_i=r \}  $$

\emph{Let us inspect visually the first occurred events}:

```{r}
head(dat.gam)
```

\emph{At event-1, there is no previous event, so popularity for the receiver is $0$ at that point. For the second event, we can check if the receiver of is the one involved in the first one, but this is not the case. For event-3, we check if receiver is one of the two previously observed, but it is not the case either. Once we arrive at time 4, we can see that the receiver is the same as the one in the first event: receiver popularity assumes thus value $1$ in this case. For the events 5 and 6 popularity is again $0$}.

\colorbox{darkseagreen}{D1.5}: Write a function `receiver_popularity` that, given the case-control dataset and the ordinal position of the event in the time sequence, computes the number of previously occurred interactions with the same receiver as the event or the non-event (according to the optional parameter `ev=TRUE`). Apply the function to the events and the sampled non-events and compute the difference.

```{r}
receiver_popularity <- function(dat.gam, k, ev=TRUE) {
  
  # Check if k is within bounds
  if (k < 1 || k > nrow(dat.gam)) {
    stop("k is out of bounds.")
  }
  
  # If k is 1, there's no history to compare, return 0
  if (k == 1) {
    return(0)
  } else {
    
    # Calculate the history of receivers up to the (k-1)th element
    history_receiver <- dat.gam$receiver[1:(k-1)]
    
    # Ensure that dat.gam has the required columns
    if (!"receiver" %in% names(dat.gam)) {
      stop("dat.gam does not contain the column 'receiver'.")
    }
    if (!"non.receiver" %in% names(dat.gam) && !ev) {
      stop("dat.gam does not contain the column 'non.receiver'.")
    }
    
    # Calculate popularity based on the value of ev
    if (ev) {
      return(sum(history_receiver == dat.gam$receiver[k]))
    } else {
      return(sum(history_receiver == dat.gam$non.receiver[k]))
    }
  }
}

```

```{r}
dat.gam$endPop1 <- sapply(1:nrow(dat.gam), 
                          function(x) receiver_popularity(dat.gam, x, ev=TRUE))
dat.gam$endPop2 <- sapply(1:nrow(dat.gam), 
                          function(x) receiver_popularity(dat.gam, x, ev=FALSE))
endPop_diff = dat.gam$endPop1 - dat.gam$endPop2
```

\colorbox{darkseagreen}{D1.6}: Fit a linear model with `endPop_diff` only. Is this covariate significant? Interpret the results. 

```{r}
summary(gam(y ~ endPop_diff - 1, 
            data=dat.gam, 
            family="binomial"))
```

\emph{The endogenous covariate Receiver Popularity is significant and has a positive coefficient, meaning that the rate of interactions is larger for popular receiver w.r.t. unpopular ones.}


## 2.   Towards the computaion of endogenous dyadic and triadic covariates

### 2.1.    Reciprocity and Cyclic Closure

\colorbox{darkseagreen}{Demo 2}:

\colorbox{darkseagreen}{D2.1}: Write a function `rec_cyc` that, given the case-control dataset and the ordinal position of the event in the time sequence, computes two indicators for  \textcolor{mauvetaupe}{Reciprocity} and  \textcolor{mauvetaupe}{Cyclic Closure}. The function should have an optional parameter `ev=TRUE` to determine which columns to use for event's sender and receiver information. Apply the function to the events and the sampled non-events, then compute the difference between these two indicators for events and non-events.

```{r}
rec_cyc <- function(dat.gam, k, ev=TRUE) {
  
  # Determine which column indices to use based on the 'ev' flag
  if (ev) {
    s <- dat.gam[k, 2]   # 's' is the second column (event sender)
    r <- dat.gam[k, 3]   # 'r' is the third column (event receiver)
  } else {
    s <- dat.gam[k, 4]   # 's' is the fourth column (event sender)
    r <- dat.gam[k, 5]   # 'r' is the fifth column (event receiver)
  }
  
  # Check if k is within bounds of dat.gam
  if (k < 1 || k > nrow(dat.gam)) {
    stop("k is out of bounds.")
  }
  
  # If k is 1, there's no history to compare, return (0, 0)
  if (k == 1) {
    return(c(0, 0))
  } else {
    # Initialize variables to store reciprocity and cyclic closure indicators
    rec_id <- 0
    cyc_id <- 0
    
    # Determine the starting point in the past to begin examining
    prev <- which(dat.gam[1:(k-1), 2] == s & dat.gam[1:(k-1), 3] == r)
    if (length(prev) > 0) {
      prev <- prev[length(prev)] + 1
    } else {
      prev <- 1
    }
    
    # Check if there are third parties interacting towards 's'
    t <- which(dat.gam[prev:k, 3] == s)
    t <- prev + t - 1
    l <- dat.gam[t, 2]
    common.nodes <- unique(l)
    
    if (length(common.nodes) != 0) {
      # Iterate over each common node 'a'
      for (a in common.nodes) {
        
        # Check if 'a' is the receiver 'r' (reciprocity check)
        if (a == r) {
          rec_id <- max(rec_id, 1)
        } else {
          # Find the latest time 'a' interacted towards 's'
          stop_t <- dat.gam$time[t[which(dat.gam[t, 2] == a & 
                                         dat.gam[t, 3] == s)]]
          stop_t <- max(stop_t)
          
          # Check if 'r' interacted towards 'a' before 'stop_t'
          t2 <- which(dat.gam[prev:max(which(dat.gam$time == stop_t)), 2] == r &
                      dat.gam[prev:max(which(dat.gam$time == stop_t)), 3] == a)
          
          # If at least one such event is found, set cyclic closure indicator
          if (length(t2) > 0) {
            cyc_id <- max(cyc_id, 1)
          } else {
            # Check if 'r' interacted towards 'a' before 's' interacted towards 'r'
            t3 <- which(dat.gam[1:prev, 2] == r & dat.gam[1:prev, 3] == a)
            if (length(t3) > 0) {
              cyc_id <- max(cyc_id, 1)
            }
          }
        }
      }
    }
  }
  
  # Return the reciprocity and cyclic closure indicators
  return(c(rec_id, cyc_id))
}
```

```{r}
events <- t(sapply(1:nrow(dat.gam), 
                 function(x) rec_cyc(dat.gam, x, ev=TRUE)))
non_events <- t(sapply(1:nrow(dat.gam), 
                function(x) rec_cyc(dat.gam, x, ev=FALSE)))

dat.gam <- cbind(dat.gam, 
                 rec1 = events[,1],
                 cyc1 = events[,2],
                 rec2 = non_events[,1],
                 cyc2 = non_events[,2])
dat.gam$rec_diff = dat.gam$rec1 - dat.gam$rec2
dat.gam$cyc_diff = dat.gam$cyc1 - dat.gam$cyc2
```

\colorbox{darkseagreen}{D2.2}: Check the function \texttt{n\_effects} uploaded with the input data. Apply the function to the data concerning events and non-events. Which columns of the output correspond to the reciprocity you computed in \colorbox{darkseagreen}{D2.1}?

REMARK! Attention to the order of the columns of the dataset!

```{r}
events_alt <- n_effects(dat.gam[,c(2,3,1)], dat.gam[,c(4,5,1)])[[1]]
non_events_alt <- n_effects(dat.gam[,c(2,3,1)], dat.gam[,c(4,5,1)])[[2]]
```

```{r}
# events_alt$r1==dat.gam$rec1
```

```{r}
# non_events_alt$r1==dat.gam$rec2
```

\texttt{n\_effects} \emph{function analyzes the reciprocity and transitivity effects in a network by updating the relevant metrics for both events and non-events in the dataset. It processes each interaction to compute binary indicators, counts of past events, exponential time decay, and smooth functions of time for various types of triadic closures, considering both ordered and unordered events. The function returns the datasets with these computed metrics for further analysis. We will inspect more this function in the fourth Session of the Tutorial.}

\colorbox{darkseagreen}{D2.3}: Fit a linear model with \texttt{endPop\_diff} and \texttt{rec\_diff}. What happens to \texttt{endPop\_diff}? Interpret the results.

```{r}
summary(gam(y ~ endPop_diff + rec_diff - 1, data=dat.gam, 
            family="binomial"))
```

\emph{By taking into account reciprocity effect, receiver popularity is not anymore significant. Nevertheless, it is important to keep it in the model in order to account for the hierarchical structure}.

\emph{Reciprocity has a positive impact, meaning that whenever reciprocity status is equal to $1$ (there is an event waiting to be reciprocated), the rate of the interaction is larger.}

\colorbox{darkseagreen}{D2.4}: Add \texttt{cyc\_diff} to the fitting. Interpret the results. 

```{r}
summary(gam(y ~ endPop_diff + rec_diff + cyc_diff - 1, data=dat.gam, 
            family="binomial"))
```

\emph{Cyclic closure is tested as significant in this model formulation.}

### 2.2.    Transitive Closure

\colorbox{darkseagreen}{Demo 3}: 

\colorbox{darkseagreen}{D3.1}: Write a function \texttt{transitive\_closure} that, given the case-control dataset and the ordinal position, computes an indicator for  \textcolor{mauvetaupe}{Transitive Closure} in the \textcolor{mauvetaupe}{short and long term}. The function should have a parameter \texttt{alpha} determining short and long term and an optional parameter \texttt{ev=TRUE}. The \textcolor{mauvetaupe}{event of interest} is represented (in this case) by the (second-leg) of the triangle $a \rightarrow r$.

```{r}
transitive_closure_slt <- function(dat.gam, k, alpha, ev=TRUE) {
  
  current <- as.numeric(dat.gam[k, 1])
  
  # Determine which column indices to use based on the 'ev' flag
  if (ev) {
    s <- dat.gam[k, 2]   # 's' is the second column (event sender)
    r <- dat.gam[k, 3]   # 'r' is the third column (event receiver)
  } else {
    s <- dat.gam[k, 4]   # 's' is the fourth column (event sender)
    r <- dat.gam[k, 5]   # 'r' is the fifth column (event receiver)
  }
  
  # Check if k is within bounds of dat.gam
  if (k < 1 || k > nrow(dat.gam)) {
    stop("k is out of bounds.")
  }
  
  # If k is 1, there's no history to compare, return (0, 0)
  if (k == 1) {
    return(c(0, 0, 0))
  } else {
    
    # Determine the starting point in the past to begin examining
    prev <- which(dat.gam[1:(k-1), 2] == s & dat.gam[1:(k-1), 3] == r)
    if (length(prev) > 0) {
      prev <- prev[length(prev)] + 1
    } else {
      prev <- 1
    }
    
    trs_rec <- trs_long <- trs_id <- 0
    
    # Check if there are third parties interacting towards 'r'
    t <- which(dat.gam[prev:k,3]==r)
    t <- prev + t - 1
    l <- dat.gam[t,2]
    common.nodes <- unique(l)
    
    if(length(common.nodes)!=0){
      
      # Iterate over each common node 'a'
      for(a in common.nodes){
      
      # Find the latest time 'a' interacted towards 'r'
      stop_t <- dat.gam$time[t[which(dat.gam[t,2]==a & dat.gam[t,3] == r)]]
      stop_t <- max(stop_t)
      
      # Check if 's' interacted towards 'a' before 'stop_t'
      t2 <- which(dat.gam[prev:max(which(dat.gam$time==stop_t)),2]==s &
                  dat.gam[prev:max(which(dat.gam$time==stop_t)),3]==a)
      
      # If at least one such event is found, 
      # check if latest time 'a' interacted towards 'r' 
      # is larger or smaller than (current-alpha)
      if (length(t2)>0){
        if (stop_t>=(current-alpha)){
          trs_rec <- max(trs_rec,1)
        } else {
          trs_long <- max(trs_long, 1)
        }
        trs_id <- max(trs_id, 1)
      } else {
        
        # Check if 's' interacted towards 'a' before 's' interacted towards 'r'
        t3 <- which(dat.gam[1:prev,2]==s & dat.gam[1:prev,3]==a)
        if (length(t3) > 0) {
          if (stop_t>=(current-alpha)){
            trs_rec <- max(trs_rec,1)
            } else {
              trs_long <- max(trs_long, 1)
              }
          trs_id <- max(trs_id, 1)
        }
      }
      }
    }
  }
  
  return(c(trs_rec, trs_long, trs_id))
}
```

\colorbox{darkseagreen}{D3.2}:  Apply the function \texttt{transitive\_closure} to `Class` events and sampled non-events, then compute the difference between obtained indicators for events and non-events (in the short and long term). Add them to the model in \colorbox{darkseagreen}{D2.4}.

```{r}
events <- t(sapply(1:nrow(dat.gam), 
                 function(x) transitive_closure_slt(dat.gam, x, alpha = 10, ev=TRUE)))
non_events <- t(sapply(1:nrow(dat.gam), 
                function(x) transitive_closure_slt(dat.gam, x, alpha = 10, ev=FALSE)))

dat.gam <- cbind(dat.gam, 
                 trs_rec1 = events[,3],
                 trs_rec2 = non_events[,3])
dat.gam$trs_rec = dat.gam$trs_rec1 - dat.gam$trs_rec2
```

```{r}
summary(gam(y ~ endPop_diff + rec_diff + cyc_diff + 
            trs_rec - 1, data=dat.gam, 
            family="binomial"))
```

## 3.   Time in REMs Network Statistics: Short VS Long-Term Network Statistics

\colorbox{darkseagreen}{Demo 4}: 

```{r, echo=FALSE}
knitr::include_graphics("02-Images/timeline.pdf")
```

\colorbox{darkseagreen}{Demo 4.1}: Consider the following sequence of $20$ to exercise with the network statistics computation. You find the data in \textcolor{persianred}{input02.RData}.

```{r}
# rem_dat <- matrix(c(1, "A", "B", 2, "A", "B",
#                     3, "A", "B", 4, "B", "A",
#                     5, "A", "B", 6, "B", "C",
#                     7, "C", "B", 8, "B", "A",
#                     9, "A", "C", 10, "C", "A",
#                     11, "C", "B", 12, "A", "B",
#                     13, "A", "B", 14, "A", "B",
#                     15, "B", "C", 16, "A", "B",
#                     17, "A", "C", 18, "C", "B",
#                     19, "B", "C", 20, "A", "B"),
#                   ncol=3, byrow=TRUE)
# colnames(rem_dat) <- c("time", "sender", "receiver")
# rem_dat <- data.frame(rem_dat)
# rem_dat$time <- as.numeric(rem_dat$time)
```

```{r}
# save.image(file="input02.RData")
```

```{r}
load(file="01-Data/01-Inputs/input02.RData")
```

\colorbox{darkseagreen}{Demo 4.2}: Modify the function `rec_cyc`, creating the function `rec_cyc_slt` that, given the case-control dataset and the ordinal position of the event in the time sequence, computes  indicators for  \textcolor{mauvetaupe}{Reciprocity} and  \textcolor{mauvetaupe}{Cyclic Closure}, considering their presence in general (as before), and in the \textcolor{mauvetaupe}{short and long term}. The function should have a parameter \texttt{alpha} determining short and long term and an optional parameter \texttt{ev=TRUE}. The \textcolor{mauvetaupe}{event of interest} is represented (in this case) by the reciprocal event for reciprocoty and the (second-leg) of the triangle $a \rightarrow s$. The function should have an optional parameter `ev=TRUE`.

```{r}
rec_cyc_slt <- function(dat.gam, k, alpha, ev=TRUE) {
  
  current <- as.numeric(dat.gam[k, 1])
  
  # Determine which column indices to use based on the 'ev' flag
  if (ev) {
    s <- dat.gam[k, 2]   # 's' is the second column (event sender)
    r <- dat.gam[k, 3]   # 'r' is the third column (event receiver)
  } else {
    s <- dat.gam[k, 4]   # 's' is the fourth column (event sender)
    r <- dat.gam[k, 5]   # 'r' is the fifth column (event receiver)
  }
  
  # Check if k is within bounds of dat.gam
  if (k < 1 || k > nrow(dat.gam)) {
    stop("k is out of bounds.")
  }
  
  # If k is 1, there's no history to compare, return (0, 0)
  if (k == 1) {
    return(c(0, 0, 0, 0, 0, 0))
  } else {
    # Initialize variables to store reciprocity and cyclic closure indicators
    rec_rec <- rec_long <- rec_id <- 0
    cyc_rec <- cyc_long <- cyc_id <- 0
    
    # Determine the starting point in the past to begin examining
    prev <- which(dat.gam[1:(k-1), 2] == s & dat.gam[1:(k-1), 3] == r)
    if (length(prev) > 0) {
      prev <- prev[length(prev)] + 1
    } else {
      prev <- 1
    }
    
    # Check if there are third parties interacting towards 's'
    t <- which(dat.gam[prev:k, 3] == s)
    t <- prev + t - 1
    l <- dat.gam[t, 2]
    common.nodes <- unique(l)
    
    if (length(common.nodes) != 0) {
      # Iterate over each common node 'a'
      for (a in common.nodes) {
        
        # Check if 'a' is the receiver 'r' (reciprocity check)
        if (a == r) {
          stop_t <- dat.gam$time[t[which(dat.gam[t, 2] == r & 
                                         dat.gam[t, 3] == s)]]
          stop_t <- max(stop_t)
          if (stop_t>=(current-alpha)){
            rec_rec <- max(rec_rec,1)
            } else {
            rec_long <- max(rec_long, 1)
          }
          rec_id <- max(rec_id, 1)
        } else {
          # Find the latest time 'a' interacted towards 's'
          stop_t <- dat.gam$time[t[which(dat.gam[t, 2] == a & 
                                         dat.gam[t, 3] == s)]]
          stop_t <- max(stop_t)
          
          # Check if 'r' interacted towards 'a' before 'stop_t'
          t2 <- which(dat.gam[prev:max(which(dat.gam$time == stop_t)), 2] == r &
                      dat.gam[prev:max(which(dat.gam$time == stop_t)), 3] == a)
          
          # If at least one such event is found, set cyclic closure indicator
          if (length(t2) > 0) {
            if (stop_t>=(current-alpha)){
              cyc_rec <- max(cyc_rec,1)
            } else {
              cyc_long <- max(cyc_long, 1)
            }
            cyc_id <- max(cyc_id, 1)
          } else {
            # Check if 'r' interacted towards 'a' before 's' interacted towards 'r'
            t3 <- which(dat.gam[1:prev, 2] == r & dat.gam[1:prev, 3] == a)
            if (length(t3) > 0) {
              if (stop_t>=(current-alpha)){
                cyc_rec <- max(cyc_rec,1)
              } else {
                cyc_long <- max(cyc_long, 1)
              }
              cyc_id <- max(cyc_id, 1)
            }
          }
        }
      }
    }
  }
  
  # Return the reciprocity and cyclic closure indicators
  return_object <- c(rec_rec, rec_long, rec_id, cyc_rec, cyc_long, cyc_id)
  names(return_object) <- c("rec_short", 
                            "rec_long",
                            "rec_id",
                            "cyc_short",
                            "cyc_long",
                            "cyc_id")
  return(return_object)
}
```

\colorbox{pastelyellow}{Exercise 1}: 

\colorbox{pastelyellow}{E1.1}: Apply `rec_cyc_slt` to the event sequence. Find the value of `alpha` that allows to find the following dynamics: 

```{r}
knitr::include_graphics("02-Images/dynamics-simulated.pdf")
```

```{r}
frame_1 <- t(sapply(1:20, function(x) rec_cyc_slt(dat.gam = rem_dat, k=x,
                                      alpha = 3)))
colnames(frame_1) <- c("rec_short", 
                       "rec_long",
                       "rec_id",
                       "cyc_short",
                       "cyc_long",
                       "cyc_id")
frame_1
```

\colorbox{pastelyellow}{E1.2}: Apply `transitive_closure_slt` to the event sequence with the found value for `alpha`. 

```{r}
frame_2 <- t(sapply(1:20, function(x) transitive_closure_slt(dat.gam = rem_dat, k=x,
                                      alpha = 3)))
colnames(frame_2) <- c("trs_short", "trs_long", "trs_id")
frame_2
```

\colorbox{pastelyellow}{E1.3}: Plot the obtained structures.  

```{r, echo=FALSE}
knitr::include_graphics("02-Images/solution-exercise1.pdf")
```

\colorbox{pastelyellow}{E1.4}: Create the case-control dataset (namely, sample a non-event for each event, compute the covariates for the non-events and then the difference between the covariates of the events and those of the non-events)

```{r}
combos <- expand.grid(c("A", "B", "C"), c("A", "B", "C"))
pairs <- subset(combos, Var1 != Var2)
set.seed(2)
non_rem_dat <- pairs[sample(1:nrow(pairs), 20, replace=TRUE), ]
non_rem_dat <- cbind(non_rem_dat,
                     t(sapply(1:20, function(x) 
                       rec_cyc_slt(dat.gam = non_rem_dat, 
                                   k=x, alpha = 3))),
                     t(sapply(1:20, function(x) 
                       transitive_closure_slt(dat.gam = rem_dat, 
                                              k=x, alpha = 3))))
colnames(non_rem_dat) <- c("non.sender", 
                           "non.receiver",
                           "non.rec_short", 
                           "non.rec_long",
                           "non.rec_id",
                           "non.cyc_short",
                           "non.cyc_long",
                           "non.cyc_id",
                           "non.trs_short", 
                           "non.trs_long", 
                           "non.trs_id")
```

```{r}
rem_dat <- cbind(rem_dat, frame_1)
rem_dat <- cbind(rem_dat, frame_2)
rem_dat <- cbind(rem_dat, non_rem_dat)
rem_dat <- cbind(rem_dat, 1)
colnames(rem_dat)[ncol(rem_dat)] <- "y"
rem_dat[,c("diff.rec_short", 
           "diff.rec_long",
           "diff.rec_id",
           "diff.cyc_short",
           "diff.cyc_long",
           "diff.cyc_id",
           "diff.trs_short",
           "diff.trs_long", 
           "diff.trs_id")] <- 
rem_dat[,c("rec_short", 
           "rec_long",
           "rec_id",
           "cyc_short",
           "cyc_long",
           "cyc_id",
           "trs_short",
           "trs_long", 
           "trs_id")] -
  rem_dat[,c("non.rec_short", 
           "non.rec_long",
           "non.rec_id",
           "non.cyc_short",
           "non.cyc_long",
           "non.cyc_id",
           "non.trs_short",
           "non.trs_long", 
           "non.trs_id")]
```

\colorbox{pastelyellow}{E1.5}: Fit a GAM exploring the effect of reciprocity on the long and short term. 

```{r}
summary(gam(y ~ diff.rec_short + diff.rec_long - 1,
            data=rem_dat, 
            family="binomial"))
```




\colorbox{pastelpurple}{Supplementary 1}: 

\colorbox{pastelpurple}{S1.1}: Write a function \texttt{repetition\_slt} that, given the case-control dataset and the ordinal position, computes an indicator for  \textcolor{mauvetaupe}{Repetition} in the \textcolor{mauvetaupe}{short and long term}. The function should have a parameter \texttt{alpha} determining short and long term and an optional parameter \texttt{ev=TRUE}. The \textcolor{mauvetaupe}{event of interest} is represented (in this case) by the last event of the type $s \rightarrow r$.

```{r}
repetition_slt <- function(dat.gam, k, alpha, ev=TRUE, current=NULL) {
  
  if(is.null(current)){
    current <- as.numeric(dat.gam[k, 1])
  }
  
  # Determine which column indices to use based on the 'ev' flag
  if (ev) {
    s <- dat.gam[k, 2]   # 's' is the second column (event sender)
    r <- dat.gam[k, 3]   # 'r' is the third column (event receiver)
  } else {
    s <- dat.gam[k, 4]   # 's' is the fourth column (event sender)
    r <- dat.gam[k, 5]   # 'r' is the fifth column (event receiver)
  }
  
  # Check if k is within bounds of dat.gam
  if (k < 1 || k > nrow(dat.gam)) {
    stop("k is out of bounds.")
  }
  
  # If k is 1, there's no history to compare, return 0
  if (k == 1) {
    return(c(0, 0, 0))
  } else {
    # Initialize variables to store reciprocity and cyclic closure indicators
    rep_rec <- rep_long <- rep_id <- 0
    
    # Determine the starting point in the past to begin examining
    prev <- which(dat.gam[1:(k-1), 2] == s & dat.gam[1:(k-1), 3] == r)
    if (length(prev) > 0) {
      stop_t <- max(dat.gam[prev,"time"])
      if (stop_t>=(current-alpha)){
        rep_rec <- max(rep_rec,1)
      } else {
        rep_long <- max(rep_long, 1)
        }
      rep_id <- 1
    }
  }
  return(c(rep_rec, rep_long, rep_id))
}
```

\colorbox{pastelpurple}{S1.2}: Apply \texttt{repetition\_slt} to the event sequence with the value of \texttt{alpha} found in \colorbox{pastelyellow}{E1.1}.

```{r}
frame_3 <- t(sapply(1:20, function(x) repetition_slt(dat.gam = rem_dat, k=x,
                                      alpha = 3)))
colnames(frame_3) <- c("rep_short", "rep_long", "rep_id")
frame_3
```
## 4.   Time to work on real data... Inspecting a financial market!

```{r, echo=FALSE}
knitr::include_graphics("02-Images/exo-endo.pdf")
```

### 4.1. Background

\emph{The interbank market is a vital component of the financial system, connecting banks and other financial institutions to borrow and lend cash equivalent assets from each other. This allows banks to manage their liquidity needs and ensure they have sufficient funds to meet customer demands. In Europe, a significant portion of this interbank activity used to take place on a platform called e-MID, which ceased its activity in 2019 after 21 years of service.}

\emph{The eMID platform operates as a high-frequency trading platform, meaning transactions happen very rapidly, often in seconds. Unlike some other financial markets, transactions on e-MID are transparent. Details like the lender, borrower, traded amount, rate, and the exact time (down to the second) are all publicly available. This transparency fosters trust and efficiency within the interbank system.}

\emph{Banks operating on the interbank are required to maintain a minimum level of reserves, typically expressed as a percentage of their deposits. This reserve requirement ensures there is enough liquidity in the system to function smoothly. The reserve maintenance period, often around 45 days, refers to the timeframe within which banks need to meet this reserve requirement. The interbank market plays a crucial role in helping banks manage their reserves during this period, allowing them to borrow or lend as needed.}

\emph{For further analysis, a random sample of approximately 4,000 transactions has been extracted from the vast dataset of transactions that occurred in 2006 on the eMID platform. This sample provides a snapshot of the lending and borrowing activity within the European interbank market during that specific year. By studying these transactions, we can gain valuable insights into the behavior of banks, liquidity flows, and the overall dynamics of the interbank system.}

\emph{Please note that dates are transformed into integers by counting the number of days from 1970-01-01. Hours, minutes, and seconds are computed accordingly, i.e. dividing the integer date by 24/60/60.}

### 4.2. Covariate Computation

\emph{The computation of network statistics in performed in Java, according to the following setting:}

-   \emph{Recency window, corresponding with the short-term, is set equal to 45 days through the withinDays parameter.}
-   \emph{The exponential weight for time-weighted statistics is set equal to 0.6. It has been obtained via grid search and minimize the BIC.}

In the theoretical section we did express the short/long term covariates as follows: 

$$x^{1, \text{short}, \ldots}_{sr}(t; \alpha) = 1\{ t_i < t: t_i \text{ meeting conditions} \ldots , t_i \ge (t-\alpha) \}$$

$$x^{1, \text{long}, \ldots}_{sr}(t; \alpha) = 1\{ t_i < t: t_i \text{ meeting conditions} \ldots , t_i < (t-\alpha) \}$$

\emph{Nevertheless, it is possible to consider a decay function to account for the passage of time in the long term.}

$$ x^{\mathbb{W}, \text{long}, \ldots}_{sr}(t; \alpha, \delta) =  
1\{ t_i < t: t_i \text{ meeting conditions} \ldots , t_i < (t-\alpha) \} \times \frac{1}{\left(t - t_i \right)^{\beta}} $$

-   \emph{Start and end dates represent the period of observation. Dates are transformed into integers by counting the number of days from 1970-01-01}.

### 4.3. Model Estimation

\emph{REMs can be estimated via generalized additive models (GAMs). 

We will consider a baseline model (M) and will add more refined network statistics. More specifically,}

- \emph{M includes statistics computed over the whole observation period;}
- \emph{M\_TW include *time-weighted* network statistics}.

\colorbox{darkseagreen}{Demo 5}: 

\colorbox{darkseagreen}{Demo 5.1}: Load the data in \textcolor{persianred}{input03.RData}.

```{r}
load("01-Data/01-Inputs/input03.RData")
```

\colorbox{darkseagreen}{Demo 5.2}: In examining the case-control dataset, what specific information indicates that a \textcolor{mauvetaupe}{stratified model} will be used?

\emph{Non-events are lender stratified to take into account lenders' eterogeneity. For each observed event, the corresponding non-event has the same lender.}

#### 4.3.1. Baseline Model

\colorbox{darkseagreen}{D5.3}: Fit the \textcolor{mauvetaupe}{baseline model}, including nodal, diadic, and extra-diadic statistics. 

\emph{The baseline model includes nodal, diadic, and extra-diadic statistics evaluated during the whole period of observation, i.e, during the trading year 2006.}

\emph{Nodal endogenous attributes like} _RecNetBal_ \emph{are also included. This statistics refer to the difference between the lent and the borrowed amount of a bank. The statistics} _EdBalDif_ \emph{is similarly defined. It refers to the same difference but evaluated across dyads, i.e. across the pairs of lenders (senders) and borrowers (receivers).}

\emph{Please note that nodal statistics are referred to receivers (Rec...) rather than senders. This is because the NCCS is sender-based to account for lenders' heterogeneity.}

```{r}
M = gam(one ~ ## OUT-DEGREE + OUT-ACTIVITY + IN-DEGREE + IN-ACTIVITY
          RecOutDeg + RecNROutAct + RecInDeg + RecNRInAct +
          ## NODE BALANCE
          RecNetBal +
          ## TIME FROM LAST EVENT
          RecLastTime +
          ## ASSORTATIVITY BY DEGREE AND BY INTENSITY
          SdrOutDeg_RecInDeg + SdrNROutAct_RecNRInAct +
          ## REPETITION AND RECIPROCITY
          EdTrt + EdRec +
          ## DYADIC BALANCE
          EdBalDif + 
          ## TRANSITIVE CLOSURE + CYCLIC CLOSURE + SHARED LENDERS + SHARED BORROWERS
          EdTran + EdClos + EdShrBors + EdShrLens - 1,

        data=dat.gam, 
        family="binomial")
```

```{r}
save(M, file="01-Data/02-Gam-Fits/baseline-model.RData")
summary(M)
```

-   \emph{Positive and highly significant in-degree (RecInDeg): This suggests that certain actors within your network are consistently receiving a high volume of actions or interactions from others. They are the targets of activity. This could indicate popularity or central role within the network.}
-   \emph{Positive and highly significant in-intensity (RecNRInAct): This means that the actions directed towards these high in-degree actors are not only frequent but also of high intensity or importance. This could suggest strong credit relationships between banks.}
-   \emph{Negative and weakly significant assortativity (by degree and by intensity) (SdrOutDeg\_RecInDeg and SdrNROutAct\_RecNRInAct): Assortativity by degree indicates that high-degree actors (those involved in many interactions) tend to connect with low-degree actors (those involved in fewer interactions), and viceversa. Assortativity by intensity indicates that actors involved in high-intensity interactions tend to connect with actors involved in low-intensity interactions. Overall, the negative assortativity suggests a pattern of heterogeneity in the network. There's not a strong tendency for like to attract like in terms of interaction frequency or intensity. The weak significance implies this pattern might not be a dominant feature of your network.}
-   \emph{Slightly significant positive transitivity (EdTran): This indicates a mild tendency for triangles to form in your network. This suggests some degree of clustering or community formation within your network.}
-   \emph{Negative and highly significant recency parameter (RecLastTime): When the recency parameter is negative, it means that if an event has recently occurred between two actors, it is less likely that the same type of event will happen again immediately afterward. Relatedly, as time passes since the last event, the likelihood of a similar event occurring between those same actors gradually increases.}
-   \emph{Positive and highly significant net balance parameter: The RecNetBal statistic calculates the difference between a bank's total lending amount (money it lends to other banks) and its total borrowing amount (money it borrows from other banks). A positive net balance means a bank has lent out more money than it has borrowed. In other words, it is a net creditor in the interbank lending network.}
-   \emph{In summary, the network appears to have key players (high in-degree) who are the targets of frequent and important actions. While there is some clustering, the overall network structure is heterogeneous, with high-degree and high-intensity actors often connecting with their lower-degree and lower-intensity counterparts.}

#### 4.3.2. Time-Weighted Network Statistics

\colorbox{darkseagreen}{Demo 5.4}:  Incorporate in the model \textcolor{mauvetaupe}{time-weighted network statistics}.

\emph{Time-weighted statistics prioritize recent data points, assigning greater higher weights to more recent observations, typically through an exponentially decaying weight parameter. The higher the value of the decay parameter, the greater the emphasis on recent transactions. In contrast, a lower alpha value gives more weight to historical data and provides a longer-term perspective.}

\emph{In this exercise $\alpha = 0.6$. The value is obtained via a grid search method and chosen to minimize the BIC criterion. Moreover, the chosen value is consistent with reserve maintenance periods defined by the European Central Bank.}

```{r}
M_TW = gam(one ~  
             ## OUT-DEGREE + OUT-ACTIVITY + IN-DEGREE + IN-ACTIVITY
             RecOutDeg + RecNROutAct + RecInDeg + RecNRInAct +
             ## NODE BALANCE
             RecNetBal +
             ## TIME FROM LAST EVENT
             RecLastTime +
             ## ASSORTATIVITY BY DEGREE AND BY INTENSITY
             SdrOutDeg_RecInDeg + SdrNROutAct_RecNRInAct +
             ## REPETITION AND RECIPROCITY
             EdTWTrt + EdTWRec +
             ## DYADIC BALANCE
             EdBalDif + 
             ## TRANSITIVE CLOSURE + CYCLIC CLOSURE + SHARED BORROWERS + SHARED LENDERS
             EdTWTran + EdTWClos + EdTWShrBors + EdShrLens -1,

           family = "binomial", 
           data = dat.gam)
```

```{r}
save(M_TW, file="01-Data/02-Gam-Fits/time-weighted-model.RData")
summary(M_TW)
```

\emph{The network exhibits a persistent hierarchy, characterized by a small subset of actors consistently receiving a disproportionate share of interactions (positive and highly significant in-degree and in-intensity over the long term). These relationships are not driven by immediate reciprocity or short-term exchanges (non-significant reciprocity and short-term effects). Moreover, the absence of significant time-weighted dyadic and extra-dyadic effects indicates that the timing and structure of past interactions do not significantly influence the likelihood of future interactions beyond the general tendency towards certain actors. This suggests that the network structure is primarily shaped by enduring relationships and individual actor characteristics, rather than complex temporal dependencies or broader network influences. The stability of these patterns over time further underscores the importance of sustained, potentially asymmetric relationships in this network.}

#### 4.3.3. Model Comparison

\colorbox{darkseagreen}{D5.5}: Compare the two models above using AIC or BIC. 

```{r}
AIC(M, M_TW)
BIC(M, M_TW)
```

```{r}
save.image("01-Data/03-Output/output.RData")
```
knitr::knit_hooks$set(purl = knitr::hook_purl)
knitr::opts_chunk$set(echo = TRUE)
load(file="01-Data/02-Gam-Fits/gam_dt.only.RData")
load(file="01-Data/02-Gam-Fits/gam_tr.only.RData")
load(file="01-Data/02-Gam-Fits/gam_d.only.RData")
setwd("/Users/martina.boschi/Dropbox/Sunbelt_2024/04-GitHub-Repository/REM-tutorial/01-REM2point0/03-Mixed_effect_additive_REMs")
knitr::knit_hooks$set(purl = knitr::hook_purl)
knitr::opts_chunk$set(echo = TRUE)
if (!require("mgcv", quietly = TRUE)) {
# If not installed, install it
install.packages("mgcv")
# Load the package
library("mgcv")
} else {
if (!require("splines", quietly = TRUE)) {
install.packages("splines")
library("splines")
} else {
if (!require("ggplot2", quietly = TRUE)) {
install.packages("ggplot2")
library("ggplot2")
} else {
if (!require("tidyverse", quietly = TRUE)) {
install.packages("tidyverse")
library("tidyverse")
} else {
if (!require("RColorBrewer", quietly = TRUE)){
install.packages("RColorBrewer")
} else {
if (!require("mgcViz", quietly = TRUE)){
install.packages("mgcViz")
} else {
library("mgcv")
library("splines")
library("ggplot2")
library("tidyverse")
library("RColorBrewer")
library("mgcViz")
}
}
}
}
}
}
load(file="01-Data/01-Inputs/input00.RData")
head(FR[,c("LifeForm", "Taxon",
"Region", "FirstRecord",
"Source")])
head(first_records[,c("year","lf",
"species",
"region")])
invaded.regions <- function(sp.n, r.n, y, native, first_records){
# Convert input arguments to numeric type if not already
sp.n <- as.numeric(sp.n)
r.n <- as.numeric(r.n)
y <- as.numeric(y)
# Get unique combinations of species number and region number from native data
t <- unique(as.vector(subset(native, sp.num == sp.n, r.num)))
# Get region numbers from first records data where species number matches
pr <- as.vector(subset(first_records, sp.num == sp.n, r.num))
# If the invasion is both present in first records data and in native range
# consider the former as actual piece of information
t <- setdiff(t, pr)
# Find indices of first records occurring before end date for the species
set.sp <- which(first_records$sp.num == sp.n & first_records$year < y)
# Combine regions in native range with regions in first records before date
t <- na.omit(c(t, first_records$r.num[set.sp]))
# Do not consider the involved region
inv <- unlist(setdiff(t, r.n))
# Return invaded regions
return(inv)
}
knitr::opts_chunk$set(echo = TRUE)
load(file = "00-Data/simdat.RData")
head(simdat)
knitr::opts_chunk$set(echo = TRUE)
load(file = "00-Data/simdat.RData")
head(simdat)
#Libraries that we are going to use
library(tidyr)
library(mgcv)
set.seed(1234)
#Number of individuals
p <- 20
risk_set <- cbind(rep(1:p,each=p),rep(1:p,p))
#Remove cases where sender = receiver
t <- which(risk_set[,1] == risk_set[,2])
risk_set <- risk_set[-t,]
risk_set <- as.data.frame(risk_set)
colnames(risk_set) <- c("sender","receiver")
#Add unique ID to each pair
risk_set$id <- 2^risk_set$sender*3^risk_set$receiver
head(risk_set)
non.id <- NULL
#For each event sample a non-event, i.e. its ID
for(i in 1:nrow(simdat))
non.id <- c(non.id,sample(risk_set$id[risk_set$id!=simdat$id[i]],1))
row_n <- NULL
for(i in 1:length(non.id))
{
row_n <- c(row_n,which(risk_set$id == non.id[i]))
}
#Timestamps for the non-events
non.tm <- simdat$time
#Create a dataset of non-events consisting of sender,receiver and time
non.data <- as.data.frame(cbind(risk_set$sender[row_n],risk_set$receiver[row_n],non.tm))
colnames(non.data)[1:3] <- c("sender","receiver","time")
View(non.data)
rez <- n_effects(simdat,non.data)
load("00-Data/solution.RData")
View(non.data)
#Target variable
y<-rep(1,nrow(simdat))
#Define a variable as the difference between event and non-event
x.t1 <- simdat$t1-non.data$t1
#Fit the model
gam.t1<-gam(y~-1+ x.t1,family=binomial)
#Model summary
summary(gam.t1)
x.t2 <- simdat$t2-non.data$t2
gam.t2<-gam(y~-1+ x.t2,family=binomial)
#Model summary
summary(gam.t2)
x.t3  <- simdat$t3-non.data$t3
gam.t3<-gam(y~-1+ x.t3,family=binomial)
#Model summary
summary(gam.t3)
#Smooth function of time defined as the most distant triad
#Construct the object combining statistics values for events and non-events.
tm.mat<-cbind(simdat$t4b,non.data$t4b)
#Construct the object identifying whether events and non-events were transitive ones:
id.mat<-cbind(simdat$t1,-non.data$t1)
#Model fitting
gam.t4b<-gam(y~ -1+ s(tm.mat, by=id.mat) ,family = binomial)
#Model summary
summary(gam.t4b)
#Create a sequence of equally spaced time points
ts<-seq(min(simdat$t4b[simdat$t4b!=0]),max(simdat$t4b),length=200)
#Create an object based on these generated time points
ndat<-data.frame(tm.mat=ts,id.mat=rep(1,200))
#Use gam model to get estimates for these time points
pred<-predict(gam.t4b,newdata = ndat,type="terms")
#Plot the results taking into account that the time was transformed via exp(-t)
plot(-log(ts),pred[,1],type="l", col='grey', lwd = 3, bty='n',
ylim = c(-4,1), ylab = "Transitivity", xlab ="Time")
#Smooth function of time defined as the most distant triad
tm.mat2<-cbind(simdat$t4bo,non.data$t4bo)
id.mat2<-cbind(simdat$t1o,-non.data$t1o)
#Model fitting
gam.t4bo<-gam(y~ -1+ s(tm.mat2, by=id.mat2) ,family = binomial)
#Model summary
summary(gam.t4bo)
ts2<-seq(min(simdat$t4bo[simdat$t4bo!=0]),max(simdat$t4bo),length=200)
ndat2<-data.frame(tm.mat2=ts2,id.mat2=rep(1,200))
pred2<-predict(gam.t4bo,newdata = ndat2,type="terms")
#Plot the estimate of transitivity
plot(-log(ts2),pred2[,1],type="l", lwd = 3, bty='n',
ylim = c(-4,1), ylab = "Transitivity", xlab ="Time")
AIC(gam.t1)
AIC(gam.t2)
AIC(gam.t3)
AIC(gam.t4b)
AIC(gam.t4bo)
plot(-log(ts),pred[,1],type="l", col='grey', lwd = 3, bty='n',
ylim = c(-4,1), ylab = "Transitivity", xlab ="Time")
lines(-log(ts2),pred2[,1],type="l",  lwd = 3)
lines(-log(ts),log(-log(ts)),col="red", lwd = 3)
load(file = "00-Data/re_data.RData")
head(simdat)
head(non.data)
#Target variable
y<-rep(1,nrow(simdat))
tm.mat<-cbind(simdat$t4b,non.data$t4b)
id.mat<-cbind(simdat$t1,-non.data$t1)
#Model fitting
fit <-gam(y~ -1+ s(tm.mat, by=id.mat) ,family = binomial)
#Model summary
summary(fit)
#To get a smooth estimate over the time interval of interest
#Create a sequence of equally spaced time points
ts<-seq(min(simdat$t4b[simdat$t4b!=0]),max(simdat$t4b),length=200)
#Create an object based on these generated time points
ndat<-data.frame(tm.mat=ts,id.mat=rep(1,200))
#Using gam model get estimates for these specific time points
pred<-predict(fit,newdata = ndat,type="terms")
#Plot the results taking into account that the time was transformed via exp(-t)
plot(-log(ts),pred[,1],type="l", lwd = 3, bty='n', ylim = c(-4,1),
ylab = "Transitivity", xlab ="Time")
#Define model covariates
s_out <- simdat$s_out - non.data$s_out
s_in <- simdat$s_in - non.data$s_in
r_out <- simdat$r_out - non.data$r_out
r_in <- simdat$r_in - non.data$r_in
#Fit the model
fit2 <-gam(y~-1+ s_out + s_in + r_out + r_in + s(tm.mat, by=id.mat) ,family = binomial)
summary(fit2)
ndat2<-data.frame(tm.mat=ts,id.mat=rep(1,200),
s_out = rep(1,200),r_out = rep(1,200),
s_in = rep(1,200), r_in = rep(1,200))
pred2<-predict(fit2,newdata = ndat2,type="terms")
plot(-log(ts),pred2[,5],type="l", lwd = 3, bty='n', ylim = c(-2,2),
ylab = "Transitivity", xlab ="Time")
sender_re <- factor(cbind(simdat$sender,non.data$sender))
dim(sender_re) <- c(nrow(simdat),2)
receiver_re <- factor(cbind(simdat$receiver,non.data$receiver))
dim(receiver_re) <- c(nrow(simdat),2)
id <-cbind(rep(1,nrow(simdat)),rep(-1,nrow(simdat)))
fit3<-gam(y~-1+ + s_out + s_in + r_out + r_in
+ s(tm.mat, by=id.mat)
+ s(sender_re, by = id, bs = 're')
+ s(receiver_re, by = id, bs = 're'),family=binomial)
summary(fit3)
ndat3<-data.frame(tm.mat=ts,id.mat=rep(1,200),
s_out = rep(1,200),r_out = rep(1,200),
s_in = rep(1,200), r_in = rep(1,200),
sender_re = rep(1,200),id = rep(1,200),
receiver_re = rep(1,200))
pred3<-predict(fit3,newdata = ndat3,type="terms")
plot(-log(ts),pred3[,5],type="l", lwd = 3, bty='n', ylim = c(-4,2),
ylab = "Transitivity", xlab ="Time")
knitr::opts_chunk$set(echo = TRUE)
load("mnf-raw.RData")
load("mnf-raw.RData")
setwd("/Users/martina.boschi/Dropbox/Sunbelt_2024/04-GitHub-Repository/REM-tutorial/01-REM2point0/05-Global_covariates")
load("00-Data/mnf-raw.RData")
n<-nrow(mnf.raw)
View(mnf.raw)
knitr::opts_chunk$set(echo = TRUE)
day<-floor(mnf.raw$tms)
dow<-day%%7
hist(dow,breaks = seq(-.5,6.5),main = "day of week")
tod<-(mnf.raw$tms-day)*24
hist(tod,breaks = 24,main = "time of day")
# Simulate shift with as a mean roughly the event time horizon (270 days)
set.seed(1)
p<-159
tau<-rexp(p^2,1/270)
dgnl<-(0:(p-1))*p+(1:p)
tau[dgnl]<-NA
tms.shift<-mnf.raw$tms + tau[mnf.raw$s+(mnf.raw$r-1)*p]
T<-max(mnf.raw$tms)
sum(sapply(tms.shift, function(tm,tau){sum((tm>tau)&(tm<(tau+T)),na.rm = TRUE)>1},tau=tau))
resample <- function(x, ...) x[sample.int(length(x), ...)]
event.ids<-mnf.raw$s+(mnf.raw$r-1)*p
non.event.ids<-apply(cbind(tms.shift,event.ids),1,function(x,tau)
{resample(setdiff((1:length(tau))[(x[1]>tau)&(x[1]<(tau+T))],c(NA,x[2])))[1]},tau=tau)
day.ev<-floor(mnf.raw$tms)
tod.ev<-(mnf.raw$tms-day.ev)*24
tms.nv<-mnf.raw$tms+tau[event.ids]-tau[non.event.ids]
day.nv<-floor(tms.nv)
tod.nv<-(tms.nv-day.nv)*24
par(mfrow=c(1,2))
hist(tod.ev)
hist(tod.nv)
dat<-data.frame(tod.ev=tod.ev,tod.nv=tod.nv)
dow.ev<-mnf.raw$tms%%7
dow.nv<-tms.nv%%7
par(mfrow=c(1,2))
hist(dow.ev,breaks=7)
hist(dow.nv,breaks=7)
bh.ev<-mnf.raw$tms
bh.nv<-tms.nv
dat<-cbind(dat,dow.ev,dow.nv,bh.ev,bh.nv)
dow.ev
require(mgcv)
library(mgcv)
one<-rep(1,n)
dat<-cbind(dat,one)
L.tod<-cbind(one,-one)
M.tod<-cbind(tod.ev,tod.nv)
# Note that we fit a CYCLIC spline by the option bs = "cc"
mnf1.rem<-gam(one~-1+s(M.tod,by=L.tod,bs="cc"),family = binomial)
summary(mnf1.rem)
plot(mnf1.rem)
M.dow<-cbind(dow.ev,dow.nv)
M.bh<-cbind(bh.ev,bh.nv)
mnf2.rem<-gam(one~-1+s(M.tod,by=L.tod,bs="cc")
+s(M.dow,by=L.tod,bs="cc") + s(M.bh,by=L.tod),family = binomial)
summary(mnf2.rem)
plot(mnf2.rem)
setwd("/Users/martina.boschi/Dropbox/Sunbelt_2024/04-GitHub-Repository-answer/REM-tutorial/01-REM2point0/06-REMs_with_millions_of_events")
load("00-Data/mnf-raw.RData")

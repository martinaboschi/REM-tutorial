---
title: "Relational Event Models 2.0"
author: "Boschi, Martina"
date: "2024-06-24"
output:
  pdf_document: default
  html_notebook: default
subtitle: "Mixed effect additive REMs - Tutorial Section: Solution"
header-includes:  
- \usepackage{xcolor}  
- \definecolor{persianred}{rgb}{0.8, 0.2, 0.2}
- \definecolor{persianred}{rgb}{0.8, 0.2, 0.2}
- \definecolor{pastelyellow}{rgb}{0.99, 0.99, 0.59}
- \definecolor{pastelpurple}{rgb}{0.7, 0.62, 0.71}
- \definecolor{cerulean}{rgb}{0.0, 0.48, 0.65}
- \definecolor{darkseagreen}{rgb}{0.56, 0.74, 0.56}
- \definecolor{mauvetaupe}{rgb}{0.57, 0.37, 0.43}
---

```{r setup, include=FALSE}
knitr::knit_hooks$set(purl = knitr::hook_purl)
knitr::opts_chunk$set(echo = TRUE)
```

# Mixed Effect Additive REMs: Application to Alien Species Invasions

## 0.   Preparatory Steps: Introducing Alien Species Invasions

### 0.1.    Installing libraries

\emph{In the following section, we will install the necessary packages for this tutorial. The provided code ensures that the packages are installed only if they are not already present on your system.}

```{r message=FALSE, warning=FALSE}
if (!require("mgcv", quietly = TRUE)) {
  # If not installed, install it
  install.packages("mgcv")
  # Load the package
  library("mgcv")
} else {
  if (!require("splines", quietly = TRUE)) {
    install.packages("splines")
    library("splines")
  } else {
    if (!require("ggplot2", quietly = TRUE)) {
      install.packages("ggplot2")
      library("ggplot2")
    } else {
      if (!require("tidyverse", quietly = TRUE)) {
        install.packages("tidyverse")
        library("tidyverse")
      } else {
        if (!require("RColorBrewer", quietly = TRUE)){
          install.packages("RColorBrewer")
        } else {
          if (!require("mgcViz", quietly = TRUE)){
            install.packages("mgcViz")
          } else {
            library("mgcv")
            library("splines")
            library("ggplot2")
            library("tidyverse")
            library("RColorBrewer")
            library("mgcViz")
          }
        }
      }
    }
  }
}
```

\emph{During the tutorial, we will refer to the following color palettes to improve the visualization of the results.}

```{r}
pal.blue <- brewer.pal(9, "Blues")
pal.rose <- brewer.pal(9, "RdPu")
colors <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2",
            "#D55E00", "#CC79A7", "#999999", "#66C2A5", "#FC8D62")
```

### 0.2.    Introducing alien species invasions

```{r, echo=FALSE}
knitr::include_graphics("02-Images/insects.pdf")
```

\colorbox{darkseagreen}{Demo 1}: 

\colorbox{darkseagreen}{D1.1}: Load the input data \textcolor{persianred}{"input00.RData"}. 

```{r}
load(file="01-Data/01-Inputs/input00.RData")
```

\colorbox{darkseagreen}{D1.2}: Inspect the original data contained in the object `FR`. Have a look at the columns: 
`"LifeForm"`, `"Taxon"`, `"Region"`, `"FirstRecord"`, `"Source"`. 

\emph{We firstly show how data arrives from the original source (Seebens, 2017). These data involve 17 life forms. For each record, we are able to identify the \textcolor{cerulean}{species}} (`"Taxon"`) \emph{of a certain \textcolor{cerulean}{lifeform}}} (`"Lifeform"`) \emph{that is invading a \textcolor{cerulean}{region}}} (`"Region"`) \emph{in which it was not native and was not seen before the reported \textcolor{cerulean}{year}}} (`"FirstRecord"`) \emph{. The Alien Species First Records Database collects several sources: the source of each FR is reported in the column} `"Source"`.

```{r}
head(FR[,c("LifeForm", "Taxon",
           "Region", "FirstRecord",
           "Source")])
```

\colorbox{darkseagreen}{D1.3}: Interpret this data as a \textcolor{mauvetaupe}{relational event network}. Define \textcolor{mauvetaupe}{sender set}, \textcolor{mauvetaupe}{receiver set}, and \textcolor{mauvetaupe}{time-window}. 

\emph{We recall that a \textcolor{cerulean}{first record} is the year ($t$) when a (non-native) species $s$ first invades region $r$. The following dataset, `FR`, already contains information we need to interpret first records as \textbf{relational events} $(s,r,t)$.}

\emph{Particularly, the \textcolor{mauvetaupe}{sender set} $\mathcal{S}$ is composed of the unique recorded species, while regions of the world (countries and islands) form the \textcolor{mauvetaupe}{receiver set} $\mathcal{C}$. The \textcolor{mauvetaupe}{time window} spans from $t_0=1880$ to $T=2005$.}

\colorbox{darkseagreen}{D1.4}: Inspect the object `native`. A species' \textcolor{cerulean}{native range} (NR) is the collection of areas where it is indigenous. How would you relate this concept to that of \textcolor{mauvetaupe}{risk set}?

\emph{Slightly more liberally, we refer to \textcolor{cerulean}{native range} as the set of sites where a species was already present before the start of the analysis period, which in this context is $1880$.}

`native` \emph{object contains the FRs, involving insects, that occurred before 1880. In the following chunk, an example:}

```{r}
native[sample(1:nrow(native), 10),c("species", "region")]
```

\emph{Why do we need the native range? Because the relational event is \textcolor{mauvetaupe}{non-recurrent}, namely, the event first record, for its definition, occurs only once. This also means that the \textcolor{mauvetaupe}{risk set} is reducing over time: once the event is observed, it cannot be sampled anymore as a non-event. But also because covariates are endogenous and at each time, the first time included, rely on the knowledge of which first records already occurred and this must be possible at the beginning of the analysis as well.}

\colorbox{darkseagreen}{D1.5}: Inspect the object `first_records`. Describe this relational event network and identify why it can be considered a subset of the previous one. 

```{r}
head(first_records[,c("year","lf",
           "species", 
           "region")])
```

\emph{In JuozaitienÄ— et al, Boschi et al. (2023), only a subset of these first records has been analyzed, including first records of \textcolor{cerulean}{insects, plants, birds and mammals between 1880 and 2005}, involving species for which the native range was known.The set of analyzed FRs is contained in the object} `subset`.

\emph{In this tutorial, in order to make the analysis easy to reproduce, we focus on \textcolor{cerulean}{insects} only.} `first_records` \emph{contains the insect FRs of interest. Nevertheless, the attendant to the workshop can reproduce the same analysis for the other three taxonomies. The relative materials are contained in \textcolor{persianred}{01-Supplementary-Materials}.}

\colorbox{darkseagreen}{D1.6}: Read the commented function `invaded.regions` that allows computing which regions the species invaded before the current year. Which type of covariates does this function allow to compute: \textcolor{mauvetaupe}{exogenous, endogenous, or global}?

```{r}
invaded.regions <- function(sp.n, r.n, y, native, first_records){
  
  # Convert input arguments to numeric type if not already
  sp.n <- as.numeric(sp.n)
  r.n <- as.numeric(r.n)
  y <- as.numeric(y)
  
  # Get unique combinations of species number and region number from native data
  t <- unique(as.vector(subset(native, sp.num == sp.n, r.num)))
  
  # Get region numbers from first records data where species number matches
  pr <- as.vector(subset(first_records, sp.num == sp.n, r.num))
  
  # If the invasion is both present in first records data and in native range
  # consider the former as actual piece of information
  t <- setdiff(t, pr)
  
  # Find indices of first records occurring before end date for the species
  set.sp <- which(first_records$sp.num == sp.n & first_records$year < y)
  
  # Combine regions in native range with regions in first records before date
  t <- na.omit(c(t, first_records$r.num[set.sp]))
  
  # Do not consider the involved region
  inv <- unlist(setdiff(t, r.n))
  
  # Return invaded regions
  return(inv)
}
```

### 0.3.    Building the Case-Control Dataset

\colorbox{darkseagreen}{Demo 2}: 

\colorbox{darkseagreen}{D2.1}: Consider the smaller \textcolor{mauvetaupe}{relational event network} descripted by the data in `first_records`. Begin by defining the \textcolor{mauvetaupe}{sender set} and storing it in `spec`, followed by defining the \textcolor{mauvetaupe}{receiver set} and storing it in `reg.lf`.

\emph{In the absence of further information, we assume that the sender and receiver sets comprise elements that have appeared at least once in the data}. 

```{r}
# Define sender set - species
spec <- unique(first_records$species)
(s <- length(spec))
# Define receiver set - regions
reg.lf <- unique(first_records$region)
(r <- length(reg.lf))
```

\emph{The dynamic network of FRs consists of two sets of nodes: the set of species and the set of regions. Additionally, in the dataset, we refer to a numerical formulation of species and regions, which correspond to the set of unique observed species in the data and the set of regions reported in the matrix of geographical distances, respectively.}

```{r}
reg <- colnames(data_distance)
```

\colorbox{darkseagreen}{D2.2}: Review the commented function `creating_case_control_dataset`, which utilizes information from the relational event network, noting that the relational event is non-recurrent.

\emph{As discussed in the theoretical section, to implement the \textcolor{mauvetaupe}{maximum sampled partial likelihood}, we construct the \textcolor{mauvetaupe}{case-control dataset}, which includes, for each first record, the dyad involved in the event and that involved in the \textcolor{mauvetaupe}{non-event} randomly selected from the risk-set}.

\emph{It is essential to emphasize that in this scenario, owing to the non-recurrent nature of the relational event, the risk set diminishes over time. Once the event occurs, it cannot occur again and thus, it is excluded from the dyads at risk}.

\emph{In order to address the \textcolor{mauvetaupe}{ties} in the event sequence, we exclude, for each event, all the first records that occurred in the same year from being considered as potential non-events}.

```{r}
creating_case_control_dataset <- function(first_records,
                                 spec, reg.lf, reg,
                                 seed=1234
                                 ){
  
  reg.lf.num <- match(reg.lf, reg)
  s <- length(spec)
  r <- length(reg.lf)
  
  ## POSSIBLE (S,R) INTERACTIONS ####
  # Initialize a vector to keep track of the risk set size over time
  at.risk <- NULL
  # Create a matrix to indicate possible (species, region) interactions
  alien.occ <- matrix(0, nrow = s, ncol = r) 
  rownames(alien.occ) <- spec
  colnames(alien.occ) <- reg.lf
  for (n.sp in 1:s){
    # Identify native regions for each species
    nat.id <- unique(native$r.num[native$sp.num == n.sp]) 
    # Identify regions where the species is not native
    possible.to <- setdiff(reg.lf.num,nat.id)
    # Mark these regions as possible invasion sites for the species
    alien.occ[n.sp,reg[possible.to]] <- 1
  }
  
  ## COLLECTING INFORMATION ####
  dat.gam <- data.frame(matrix(NA, nrow=nrow(first_records),ncol=6))
  colnames(dat.gam) <- c("y", "year", 
                         "sp1", "r1", 
                         "sp2", "r2")
  # The response is fixed and equal to 1
  dat.gam[,1] <- rep(1, nrow(first_records))
  
  set.seed(seed)
  # For each FR:
  for (i in 1:nrow(first_records)){
    
    ### INFORMATION CONCERNING THE EVENT ####
    # year of the invasion event
    dat.gam[i,2] <- year <- first_records[i,"year"]
    # invading species
    dat.gam[i,3] <- s.ev <- first_records[i,"species"]
    # invaded country
    dat.gam[i,4] <- r.ev <- first_records[i,"region"]
    
    ### POSSIBLE EVENTS ####
    # Events occurred at the same time of the considered event
    # are removed from the risk set
    sub_stp <- first_records[first_records$year==year,
                             c("species", "region")]
    ni <- nrow(sub_stp)
    for (j in 1:ni){
      # Mark these (species, region) pairs as not at risk
      alien.occ[sub_stp[j,1],sub_stp[j,2]] <- 0
    }
    at.risk <- c(at.risk, sum(alien.occ==1))
    
    ### SAMPLING THE NON-EVENT ####
    sr.nv<-sample(which(alien.occ!=0),1)
    # species non-event
    dat.gam[i,5] <- s.nv <- spec[(sr.nv-1)%%s+1]
    # region non-event
    dat.gam[i,6] <- r.nv <- reg.lf[(sr.nv-1)%/%s+1]
  }
  
  return(dat.gam)
}
```

\colorbox{darkseagreen}{D2.3}: Use the function `creating_case_control_dataset` with `first_records` and generate the case-control dataset. Additionally, determine the numerical codification of species and regions.

```{r}
dat.gam <- creating_case_control_dataset(first_records, 
                                         spec, reg.lf, reg)
```

\emph{The numerical codification can be derived from the objects `spec` (containing unique species involved in observed events) and `reg` (representing regions with known geographical distance information).}

```{r}
dat.gam$sp1.num <- match(dat.gam$sp1, spec)
dat.gam$r1.num <- match(dat.gam$r1, reg)
dat.gam$sp2.num <- match(dat.gam$sp2, spec)
dat.gam$r2.num <- match(dat.gam$r2, reg)
```

```{r}
head(dat.gam[c("year","sp1", "r1","sp2", "r2")])
head(dat.gam[c("year","sp1.num", "r1.num","sp2.num", "r2.num")])
```

\emph{The case-control dataset, with one sampled non-event for each event, represents the starting point of our analysis. 
For each section of this tutorial, a `RData` object is stored. All the inputs for the exercises of the section can be found in \textcolor{persianred}{01-Input-Data}. Also, intermediate solutions of the exercises are stored and can be found in \textcolor{persianred}{02-Intermediate-Solutions}.}

### 0.4.    Linear Effect of Climatic Dissimilarity

\emph{This section aims to briefly recap the possibility of estimating the coefficients of a relational event model using a \textcolor{mauvetaupe}{Generalized Additive Model} (GAM). In principle, the model fitted in this context remains a Generalized Linear Model (GLM) due to the linear effect assumed for climatic dissimilarity.}

\colorbox{pastelpurple}{Supplementary 1}: linear modeling of  Climatic Dissimilarity!

```{r, echo=FALSE}
knitr::include_graphics("02-Images/temp-idea.pdf")
```

\colorbox{pastelpurple}{S1.1}: Write a function `climatic_dissimilarity` \textcolor{cerulean}{that, given a relational event (and all the relevant information that is required), computes the minimum temperature difference between the region involved and the previously invaded regions by the spcies}. Apply the function to the events and the sampled non-events and compute the difference. Help yourself with the figure in the following slide to understand how the covariate is computed.

\emph{\textcolor{cerulean}{Climatic dissimilarity} for the dyad (species-region) is the minimal temperature difference relative to all other regions where that species was already present before the year of interest.}

\emph{Temperature refers to the inferred yearly values of near-surface air temperature from (Watanabe et al., 2011).}

`data_temperature` \emph{contains the names of the countries in the first column and the average values of near-surface air temperature in the second column.}

```{r}
climatic_dissimilarity <- function(sp.n, r.n, y, native, first_records, 
                                   reg, data_temperature){
  
  # Convert input arguments to numeric type if not already
  sp.n <- as.numeric(sp.n)
  r.n <- as.numeric(r.n)
  y <- as.numeric(y)
  
  # Find regions invaded by the species before the current time
  inv <- invaded.regions(sp.n = sp.n, 
                         r.n = r.n, 
                         y = y, 
                         native = native, 
                         first_records = first_records)
  
  # Consider the minimum absolute difference in temperature
  # between the region of interest and those already invaded
  avg_temp_invaded <- data_temperature[data_temperature[,1] %in% reg[inv], 2]
  # Get the average temperature value for the region of interest
  avg_temp_interest <- data_temperature[r.n, 2]
  # Find the minimum absolute difference in temperature
  dt.value <- min(abs(avg_temp_invaded - avg_temp_interest))
  
  # Return the calculated climatic dissimilarity value
  return(dt.value)
}
```

```{r}
dat.gam$dt1 <- apply(dat.gam[,c("sp1.num", "r1.num", "year")], 1, 
                            function(x) climatic_dissimilarity(sp.n = x[1], 
                                        r.n = x[2], 
                                        y = x[3], 
                                        native = native, 
                                        first_records = first_records, 
                                        reg = reg, 
                                        data_temperature = data_temperature))
dat.gam$dt2 <- apply(dat.gam[,c("sp2.num", "r2.num", "year")], 1, 
                            function(x) climatic_dissimilarity(sp.n = x[1], 
                                        r.n = x[2], 
                                        y = x[3], 
                                        native = native, 
                                        first_records = first_records,
                                        reg = reg, 
                                        data_temperature = data_temperature))
dat.gam$dt = dat.gam$dt1 - dat.gam$dt2
```

```{r, echo=FALSE}
knitr::include_graphics("02-Images/temperature-covariate-computation.pdf")
```

\colorbox{pastelpurple}{S1.2}: Estimate the \textcolor{mauvetaupe}{linear effect} of climatic dissimilarity. 

```{r}
gam_dt.only <- gam(y ~ dt - 1,
    family="binomial"(link = 'logit'),
    method="REML", data=dat.gam)
```

\colorbox{pastelpurple}{S1.3}: Interpret the obtained \textcolor{mauvetaupe}{point estimate} for the impact of climatic dissimilarity. Is it positive or negative?

```{r}
summary(gam_dt.only)
```

\emph{The coefficient for Climatic Dissimilarity, which remains constant over time, is negative. This indicates that the rate of invasions tends to increase if the species has already invaded countries with similar temperatures.}

```{r}
# save(gam_dt.only, file="01-Data/02-Gam-Fits/gam_dt.only.RData")
rm(gam_dt.only)
# save.image("01-Data/01-Inputs/input01.RData")
```



## 1.   Time-Varying Effect of Trade on Species Invasions

```{r, echo=FALSE}
knitr::include_graphics("02-Images/trade-idea.pdf")
```

### 1.1.    Trade: Covariate Computation

\colorbox{darkseagreen}{Demo 3}: 

\emph{In the object} \textcolor{persianred}{"input01.RData"} \emph{you can find the case-control dataset including the values for the covariate} \textcolor{cerulean}{Climatic dissimilarity} \emph{computed for the events and the non-events. The dataset also includes the values of unique species and regions involved in the system. Furthermore, the dataset contains the numerical codifications for species and regions, referred to as} spec \emph{and} reg, \emph{respectively. Finally, you will also find the function} `bspline` \emph{, that will help us in finding a non-linear function of time, necessary for computing the time-varying effect}. 

\colorbox{darkseagreen}{D3.1}: Load the input data \textcolor{persianred}{"input01.RData"}. 

```{r}
load(file="01-Data/01-Inputs/input01.RData")
```

\colorbox{darkseagreen}{D3.2}: Write a function \texttt{log\_trade} \textcolor{cerulean}{that, given a relational event (and all the relevant information required), computes the annual trade between the involved region and the previously invaded regions by the species}. Apply the function to the events and the sampled non-events, and compute the difference. Refer to the figure in the following slide to understand how the covariate is computed.

```{r, echo=FALSE}
knitr::include_graphics("02-Images/trade-covariate-computation.pdf")
```

\emph{In the existing literature, \textcolor{cerulean}{international trade} has been recognized as a key factor in explaining the spread of alien species. Here, we consider trade as the yearly commerce between already-invaded territories and the involved region. The source information, derived from Barbieri et al. (2009), which reports trade \textcolor{cerulean}{flows among countries}, is contained in} `data_trade`.

\emph{Negative values of trade are considered equal to $0$.}

\emph{Consider the following guidelines for \textcolor{cerulean}{imputing missing trade data}:}

\emph{When a pair of nations is never mentioned in the source data, the trade volume is presumed to be $0$, based on the idea that if a value is never recorded, it should be negligible.}
\emph{When the pair is mentioned but there is a non-imputed gap at the time of interest, the trade flow is evaluated based on the latest available year for which information is available.}

```{r}
t <- which(data_trade$transfer < 0)
data_trade$transfer[t] <- 0
```

```{r}
trade.funct <- function(inv, r.n, y, reg, data_trade){
  
  # Convert input arguments to numeric type if not already
  r.n <- as.numeric(r.n)
  y <- as.numeric(y)
  
  # Check if there are already invaded countries
  if(length(inv)!=0){
    
    # Find rows that involve invaded countries as sending trade
    u <- which(data_trade$FromRegion %in% reg[inv])
    # Find rows that involve region of interest as receiving trade
    v <- which(data_trade$ToRegion == reg[r.n])
    # Find the intersection of the two sets
    w <- intersect(u,v)
    x <- data_trade[w,]
    # Consider the trade instances occurred before or at the time of interest
    x <- x[x$year<=y,]
    trade_value <- NULL
    # If there are rows in the filtered dataset
    if(nrow(x)>0){
      # For each invaded country, the maximum year is recorded
      o <- aggregate(x$year, list(x$FromRegion), FUN=max)
      # For each of them, the corresponding transfer is stored
      for (o.i in 1:nrow(o)){
        trade_value <- c(trade_value, 
                         x$transfer[x$FromRegion==o[o.i,1] & 
                                      x$year==o[o.i,2]])}
    }
  } else { 
  # If there are not already invaded countries, trade is set equal to 0
    trade_value <- 0
  }
  # Compute the log-transformed sum of trade values (with an added constant 1)
  log_trade.value <- ifelse(length(trade_value)>0, 
                            log(sum(trade_value, na.rm =T)+1),0)
  
  # Return the computed log-transformed trade value
  return(log_trade.value)
}
```

```{r}
log_trade <- function(sp.n, r.n, y, native, first_records, reg, data_trade){
  
  inv <- invaded.regions(sp.n = sp.n, 
                         r.n = r.n, 
                         y = y, 
                         native = native, 
                         first_records = first_records)
  
  log_trade.value <- ifelse(r.n==match("USACanada", reg), 
                            mean(trade.funct(inv = inv,
                                             r.n = match("United States",reg),
                                             y = y, 
                                             reg = reg,
                                             data_trade = data_trade),
                                 trade.funct(inv = inv,
                                             r.n = match("Canada",reg),
                                             y = y, 
                                             reg = reg,
                                             data_trade = data_trade)),
                            trade.funct(inv = inv,
                                        r.n = r.n,
                                        y = y,
                                        reg = reg, 
                                        data_trade = data_trade))
  
  return(log_trade.value)
}
```

```{r}
dat.gam$tr1 <- apply(dat.gam[,c("sp1.num", "r1.num", "year")], 1, 
                            function(x) log_trade(sp.n = x[1], 
                                                  r.n = x[2], 
                                                  y = x[3], 
                                                  native = native, 
                                                  first_records = 
                                                    first_records,
                                                  reg = reg,
                                                  data_trade = data_trade))
dat.gam$tr2 <- apply(dat.gam[,c("sp2.num", "r2.num", "year")], 1, 
                            function(x) log_trade(x[1], x[2], x[3], 
                                                  native = native, 
                                                     first_records = 
                                                       first_records,
                                                  reg = reg,
                                                  data_trade = data_trade))
dat.gam$tr = dat.gam$tr1 - dat.gam$tr2
```

\colorbox{darkseagreen}{D3.3}: Inspect the nature of the covariate.  Is it a \textcolor{mauvetaupe}{monadic} or \textcolor{mauvetaupe}{dyadic} covariate? 

\emph{Trade depends both on species and region (and explicitely on time as well). So it is \textcolor{mauvetaupe}{dyadic} because it involves both the sender and the receiver involved in the relational event}.

\colorbox{darkseagreen}{D3.4}: Is it an \textcolor{mauvetaupe}{endogenous} or \textcolor{mauvetaupe}{exogenous} covariate?

\emph{To compute this covariate, we need the \textcolor{cerulean}{set of invaded regions} by species $s$ by time $t$ and this is an \textcolor{mauvetaupe}{endougenous} type of information, arising from the network. Nevertheless, \textcolor{mauvetaupe}{exogenous} information is also present, concerning the flows among countries. 


### 1.2.    Effect of Trade as Spline function of Time

\emph{When dealing with time-varying effects, the coefficients representing the impact of the covariate on the hazard are no longer constant but instead are non-linear functions of time. The first step involves identifying a suitable non-linear function of time, which depends on parameters that need to be estimated through our model.}

\colorbox{darkseagreen}{D4.0} Choose the basis-dimension $q$.

\emph{Choosing the basis dimension \( q \) involves determining how many basis functions are created initially. This choice impacts the flexibility and complexity of the model. The presence of identifiability constraints can reduce the effective number of basis functions to fit the model}.

\emph{By default, the} `gam` \emph{function in the} `mgcv` {package uses a basis dimension of 10. This default value provides a good balance between model flexibility and computational efficiency, so we will use this value for our analysis.}

```{r}
q = 10
```


\colorbox{darkseagreen}{D4.1} Select the \textbf{spline basis functions types} 

\emph{When choosing the types of spline basis functions for modeling, various options are available, each with its own characteristics and advantages.

Potential choices include}:
-   \emph{\textbf{B-splines}: provide local control over the curve}.
-   \emph{\textbf{Thin Plate Regression Splines}: able to capture linear and non-linear trends effectively, useful when dealing with spatial data}.

\emph{Selecting the appropriate spline basis function type depends on the nature of the data, the desired smoothness of the model, and computational considerations.
In this first example we rely on Bsplines, that will be also used in the last Session of this Workshop, but then we will rely on the default spline type used in} `gam` (`mgcv`). 

\emph{The basis functions of B-splines are calculated using a recursive method, which can be found in the function} bspline. \emph{More detailed information will be provided in the final part of this Section. For now, understand that B-splines are computed as a linear combination of non-linear functions.}

```{r}
bspline <- function(x, k, i, m = 2) {
  # ith B-spline basis function of order m at the values in x
  # given knot locations in k
  
  if (m == -1) {
    # Base case of the recursion: 
    # when m is -1, we are at the lowest order basis function
    res <- as.numeric(x < k[i + 1] & x >= k[i])  
    # Returns 1 if x is within the interval [k[i], k[i+1])
    
  } else {
    
    # Recursive case: 
    # B-spline basis function from lower order basis functions
    # Calculate the first term's coefficient
    z0 <- (x - k[i]) / (k[i + m + 1] - k[i])
    # Calculate the second term's coefficient
    z1 <- (k[i + m + 2] - x) / (k[i + m + 2] - k[i + 1])
    
    # Recursive calls to the lower order basis functions
    res <- z0 * bspline(x, k, i, m - 1) + z1 * bspline(x, k, i + 1, m - 1)
  }
  return(res)  # Return the evaluated B-spline basis function
}
```

\colorbox{darkseagreen}{D4.2} Given \textbf{range of the variable}, select the \textbf{basis evaluation points}.

\emph{When determining the points at which the basis functions are evaluated for a variable, several choices are available, each impacting the model's representation. For B-splines, a common approach is to divide the variable's range into equally spaced intervals, For instance, for basis functions of order 2 and basis dimension of 10, we divide the time window into 14 equally spaced time points. More details will follow in the last Section of this workshop. Nevertheless, other possibilities can be opted such as exploiting the variable quantile distribution.}

```{r}
# Equally spaced knots from 1880 to 2005
n_knots = 14.
knots = seq(from = min(dat.gam$year),
            to = max(dat.gam$year),
            length.out = n_knots)
```

\colorbox{darkseagreen}{D4.3} Evaluate the $q$ \textbf{basis functions} of time $b_l(t)$.

```{r}
m = 2
basis = matrix(0, nrow = length(dat.gam$year), ncol = q)
for (j in 1:q) {
  basis[, j] = bspline(dat.gam$year, k = knots, i = j)
}

plot(y = basis[, 1],
     x = dat.gam$year,
     ylab = 'b(t) - basis function of time', xlab = 't - time',
     col = 0,
     cex = 0.2)
for (j in 1:10) {
  points(y = basis[, j],
         x = dat.gam$year,
         cex = 0.2,
         col = colors[j])
}
for (k in knots) {
  abline(v=k, lty=2, lwd=0.5)
}
```

### 1.3.    Determine Trade's Contribution

-   To the \textbf{\textcolor{mauvetaupe}{log-hazard of an interaction}}}

$$f_{sr} = ... + \sum_{j=1}^q \theta_l b_j(t) tr_{sr}(t) + ...$$
			
-   To the \textbf{\textcolor{mauvetaupe}{sampled likelihood function}}}

$$PL(\theta)= \prod_{i=1}^n \dfrac{e^{\left[\sum_{j=1}^q \theta_j b_j(t)\right] \Delta tr_{i}}}{1+e^{\left[\sum_{j=1}^q \theta_j b_j(t)\right] \Delta tr_{i}}}$$

### 1.4.    Estimate the Coefficients of the Spline

\colorbox{darkseagreen}{Demo 5}: 

\colorbox{darkseagreen}{D5.1}:Let `x.ev` and `x.nv` be $n\times 1$ vectors of covariate evaluated for events \& non-events. Then: `x = x.ev - x.nv`;

```{r}
x.ev <- dat.gam$tr1
x.nv <- dat.gam$tr2
x <- x.ev - x.nv
```

\colorbox{darkseagreen}{D5.2} Let `stp` be $n\times 1$ vector of event-times.

```{r}
stp <- dat.gam$year
```

\colorbox{darkseagreen}{D5.3} Fit the model incorporating a time-varying effect for `x`.

REMARK: default spline's type for `gam` in `mgcv` consists of \textcolor{mauvetaupe}{thin plate regression spline}. 

```{r}
gam_tr.only <- gam(y ~ s(stp, by=x) - 1,
    family="binomial"(link = 'logit'),
    method="REML", data=dat.gam)
```

### 1.5.    Interpreting Trade's Effect

\colorbox{darkseagreen}{Demo 6} 

```{r}
plot(gam_tr.only)
```


```{r}
filter_data <- which(dat.gam$tr != 0)
lp_matrix <- predict.gam(gam_tr.only, type="lpmatrix")[filter_data,]
predicted_effect_tr <- as.vector(coefficients(gam_tr.only) %*% t(lp_matrix/dat.gam$tr[filter_data]))
data_effect_tr <- data.frame(x = stp[filter_data],
                             y = predicted_effect_tr)

plot(data_effect_tr, type="l", lwd=1.5, ylim=c(-0.5, 1.2),
     xlab="Time",
     ylab="Contribution to the log-hazard")
for (l in 1:10) {
  lines(y = coefficients(gam_tr.only)[l] *
          lp_matrix[,l]/dat.gam$tr[filter_data],
         x = dat.gam$year[filter_data],
         lwd = 0.8,
         col = colors[l])
}
legend("topright",
       legend=c("Time-varying effect",
                sapply(1:10, function(x) paste("Contr. basis",
                                               as.character(x)))),
       col=c(1, colors),
       lwd=c(1.5,rep(0.8, 10)),
       cex=0.45)
```

```{r}
# save(gam_tr.only, file="01-Data/02-Gam-fits/gam_tr.only.RData")
rm(gam_tr.only, x.ev, x.nv, x, unit, stp)
# save.image("01-Data/01-Inputs/input02.RData")
```


## 2.   Non-Linear Effect of Distance on Species Invasions

```{r, echo=FALSE}
knitr::include_graphics("02-Images/distance-idea.pdf")
```

### 2.1.   Distance: Covariate Computation

\colorbox{pastelpurple}{Supplementary 2}: 

\emph{In the object} \textcolor{persianred}{"input02.RData"} \emph{you can find the case-control dataset including the values for the covariate} \textcolor{cerulean}{Climatic dissimilarity} and \textcolor{cerulean}{Trade} \emph{computed for the events and the non-events. The dataset also includes the values of unique species and regions involved in the system. Furthermore, the dataset contains the numerical codifications for species and regions, referred to as} spec \emph{and} reg, \emph{respectively. Finally, you will also find the function} `bspline` \emph{, that will help us in finding a non-linear function of time and distance, necessary for computing the time-varying and non-linear effects. Since the following Section is supplementary covariate \textcolor{cerulean}{distance} covariate has been already provided}. 

\colorbox{darkseagreen}{S2.1}: Load the input data \textcolor{persianred}{"input02.RData"}. 

```{r}
load("01-Data/01-Inputs/input02.RData")
```

\emph{We compute \textbf{distance} for the dyad (species-region) as the shortest distance among the regions in which the species is already present at that time. Distance is computed referring to the closest borders and consequently is equal to zero for neighbours. Source data for this driver consists of the R package geosphere (Hijmans et al., 2017).}

`data_distance` \emph{is a matrix with rownames and colnames referring to the regions. The corresponding element in the matrix reports the distance between the two.}

\colorbox{darkseagreen}{S2.2}: Write a function `log_distance` \textcolor{cerulean}{that, given a relational event (and all the relevant information that is required), computes the shortest distance among the regions in which the species is already present at that time}. Apply the function to the events and the sampled non-events.

```{r, echo=FALSE}
knitr::include_graphics("02-Images/distance-covariate-computation.pdf")
```

```{r}
log_distance <- function(sp.n, r.n, y, native, first_records, data_distance){
  
  # Convert input arguments to numeric type if not already
  sp.n <- as.numeric(sp.n)
  r.n <- as.numeric(r.n)
  y <- as.numeric(y)
  
  # Find regions invaded by the species before the current time
  inv <- invaded.regions(sp.n = sp.n, 
                         r.n = r.n, 
                         y = y, 
                         native = native, 
                         first_records = first_records)
  
  # Consider the logarithm of the minimum distance
  # between the region of interest and those already invaded
  log_dist.value <- log(min(data_distance[r.n, inv])+1)
  
  # Return the calculated distance
  return(log_dist.value)
}
```

```{r}
dat.gam$d1 <- apply(dat.gam[,c("sp1.num", "r1.num", "year")], 1, 
                            function(x) log_distance(x[1], x[2], x[3], 
                                                     native = native, 
                                                     first_records = 
                                                       first_records,
                                                     data_distance = data_distance))
dat.gam$d2 <- apply(dat.gam[,c("sp2.num", "r2.num", "year")], 1, 
                            function(x) log_distance(x[1], x[2], x[3], 
                                                     native = native, 
                                                     first_records = 
                                                       first_records,
                                                     data_distance = data_distance))
dat.gam$d = dat.gam$d1 - dat.gam$d2
```

```{r}
# save.image("01-Data/01-Inputs/input02.RData")
```

```{r, echo=FALSE}
knitr::include_graphics("02-Images/distance-covariate-computation.pdf")
```

### 2.2.    Effect: Spline function of Distance

\colorbox{pastelpurple}{Supplementary 3}: 

```{r}
load("01-Data/01-Inputs/input02.RData")
```

\emph{When dealing with non-linear effects, the impact of the covariate is expressed by a non-linear function of the covariate itself. In the following we will inspect a suitable non-linear function of distance, which depends on parameters that need to be estimated through our model. The steps are exactly the as those inspected in} \colorbox{darkseagreen}{Demo 4}. 

\colorbox{darkseagreen}{S3.0} Choose the basis-dimension $q$.

```{r}
q = 10
```

\colorbox{darkseagreen}{S3.1} Select the \textbf{spline basis functions types} 

```{r}
bspline
```

\colorbox{darkseagreen}{S3.2} Given \textbf{range of the variable}, select the \textbf{basis evaluation points}.

```{r}
# range of distance in the events
range(dat.gam$d1)
```

```{r}
# range of distance in the events
range(dat.gam$d2)
```

```{r}
# Equally spaced knots from 1880 to 2005
n_knots = 14
all_d_values = c(dat.gam$d1, dat.gam$d2)
knots = seq(from = min(all_d_values),
            to = max(all_d_values),
            length.out = n_knots)
```

\colorbox{darkseagreen}{D4.3} Evaluate the $q$ \textbf{basis functions} of distance $b_l(x)$ in the events and in the non-events.

```{r}
m = 2
basis_ev = basis_nv = matrix(0, nrow = length(dat.gam$year), ncol = q)
for (j in 1:q) {
  basis_ev[, j] = bspline(dat.gam$d1, k = knots, i = j)
  basis_nv[, j] = bspline(dat.gam$d2, k = knots, i = j)
}

par(mfrow=c(1,2))

plot(y = basis_ev[, 1],
     x = dat.gam$d1,
     ylab = 'b(x1) - basis function of distance in events',
     xlab = 'x1 - distance in events',
     col = 0,
     cex = 0.6,
     ylim=c(0,1))
for (j in 1:10) {
  points(y = basis_ev[, j],
         x = dat.gam$d1,
         cex = 0.2,
         col = colors[j])
}
for (k in knots) {
  abline(v=k, lty=2, lwd=0.5)
}

plot(y = basis_nv[, 1],
     x = dat.gam$d2,
     ylab = 'b(x2) - basis function of distance in non-events',
     xlab = 'x2 - distance in non-events',
     col = 0,
     cex = 0.2,
     ylim=c(0,1))
for (j in 1:10) {
  points(y = basis_nv[, j],
         x = dat.gam$d2,
         cex = 0.2,
         col = colors[j])
}
for (k in knots) {
  abline(v=k, lty=2, lwd=0.5)
}
```


```{r}
load("01-Data/01-Inputs/input02.RData")
```

### 2.3.    Determine Distance's Contribution

-   To the \textbf{\textcolor{mauvetaupe}{log-hazard of an interaction}}}

$$f_{sr} = ... + \sum_{j=1}^q \theta_j b_j[d_{sr}(t)] + ...$$
			
-   To the \textbf{\textcolor{mauvetaupe}{sampled likelihood function}}}

$$PL(\theta) = \prod_{i=1}^n \dfrac{e^{\left[\sum_{j=1}^q \theta_j b_j[d_{s_ir_i(t_i)}] - b_j[d_{s_i^\ast r_i^\ast(t_i)}] \right]}}{1+ e^{\left[\sum_{j=1}^q \theta_j b_j[d_{s_ir_i(t_i)}] - b_j[d_{s_i^\ast r_i^\ast(t_i)}] \right] }}$$



### 2.4.    Estimate the Coefficients of the Spline

\colorbox{pastelyellow}{Exercise 1}: 

\colorbox{pastelyellow}{E1.1}: Load the input data \textcolor{persianred}{"input02.RData"}. 

\colorbox{pastelyellow}{E1.2}: Let `x.ev` and `x.nv` be $n\times 1$ vectors of covariate evaluated for events \& non-events.

```{r}
x.ev <- dat.gam$d1
x.nv <- dat.gam$d2
```

\colorbox{pastelyellow}{E1.2}: Let `unit` be $n\times 1$ unit vector.

```{r}
unit <- rep(1, nrow(dat.gam))
```

\colorbox{pastelyellow}{E1.3}: Define `X`, combining `x.ev` and `x.nv` and `I` combining `unit` and `-unit`.

```{r}
X = cbind(x.ev,x.nv)
I = cbind(unit,-unit)		
```

\colorbox{pastelyellow}{E1.4} Fit the model incorporating a non-linear effect. 

REMARK: default spline's type for `gam` in `mgcv` consists of \textcolor{mauvetaupe}{thin plate regression spline}. 

```{r}
gam_d.only <- gam(y ~ s(X, by=I) - 1,
    family="binomial"(link = 'logit'),
    method="REML", data=dat.gam)
```

### 2.5.    Interpreting Distance's Effect

\colorbox{darkseagreen}{Demo 7} 

```{r}
plot(gam_d.only)
```
  

```{r}
lp_matrix <- predict.gam(gam_d.only, type="lpmatrix",
                         newdata = data.frame(X=dat.gam$d1,
                                              I=1))
predicted_effect_d <- as.vector(coefficients(gam_d.only) %*% t(lp_matrix))
data_effect_d <- data.frame(x = dat.gam$d1,
                            y = predicted_effect_d)

plot(data_effect_d, lwd=1.5,
     xlab="Distance",
     ylab="Contribution to the log-hazard",
     ylim=c(-2, 3),
     col=0)
for (l in 1:9) {
  points(y = coefficients(gam_d.only)[l] *
          lp_matrix[,l],
         x = dat.gam$d1,
         lwd = 0.8,
         cex=0.2,
         col = colors[l])
}
points(data_effect_d, cex=0.4,
       col=1)
legend("topright",
       legend=c("Non-linear effect",
                sapply(1:9, function(x) paste("Contr. basis",
                                               as.character(x)))),
       col=c(1, colors),
       lwd=c(1.5,rep(0.8, 9)),
       cex=0.45)
```

```{r}
# save(gam_d.only, file="01-Data/02-Gam-Fits/gam_d.only.RData")
rm(gam_d.only, x.ev, x.nv, x, unit, X, I)
# save.image("01-Data/01-Inputs/input03.RData")
```

## 3.   Species Invasiveness Random Effect

```{r, echo=FALSE}
knitr::include_graphics("02-Images/insect-idea.pdf")
```

### 3.1.   Species Invasiveness: Covariate Computation

\colorbox{darkseagreen}{Demo 8}:

\colorbox{darkseagreen}{D8.1}: Load the input data \textcolor{persianred}{"input03.RData"}. 

\emph{In the object} \textcolor{persianred}{"input03.RData"} \emph{you can find the case-control dataset including the values for the covariate} \textcolor{cerulean}{Climatic dissimilarity}, \textcolor{cerulean}{Trade},
\textcolor{cerulean}{Distance}, \emph{computed for the events and the non-events. The dataset also includes the values of unique species and regions involved in the system. Furthermore, the dataset contains the numerical codifications for species and regions, referred to as} spec \emph{and} reg, \emph{respectively. Finally, you will also find the function} `bspline` \emph{, that will help us in finding a non-linear function of time and distance, necessary for computing the time-varying and non-linear effects.}. 

```{r}
load("01-Data/01-Inputs/input03.RData")
```

\colorbox{darkseagreen}{D8.2}: Define the covariate: $z_{s}(t)$: \textcolor{cerulean}{involvement of species} $s$ in first record occurring at $t$. Create a $n \times 2$ matrix \texttt{sp} containing in the fist column \texttt{spec} levels related to species involved in the events and in the second those involved in the non-events. 

\emph{Existing literature already underlined the importance of taking into account, together with the relevant external drivers, the heterogeneity due to the species invasiveness (Pysek et al., 2020). We do this by including random effects related to the species factor.}

```{r}
sp1 <- dat.gam$sp1
sp2 <- dat.gam$sp2
sp <- factor(c(sp1,sp2))
dim(sp) <- c(length(sp1),2)
```

\colorbox{darkseagreen}{D8.3}: Inspect the nature of the covariate. Is it a \textcolor{mauvetaupe}{monadic} or \textcolor{mauvetaupe}{dyadic} covariate? 
It is just reporting the label of species involved $s$, so the covariate $z_{s}(t)$ is monadic. 

### 3.2.   Random Effects as Smooths

$$\gamma' z_{s}(t) = \sum_{s' \in \mathcal{S}} \gamma_{s'}  1\{s = s'\}$$

### 3.3.   Species Invasiveness' Contribution

-   To the \textbf{\textcolor{mauvetaupe}{log-hazard of an interaction}}}

$$f_{sr} = ... + \sum_{s' \in \mathcal{S}} \gamma_{s'}  1\{s = s'\} + ...$$
			
-   To the \textbf{\textcolor{mauvetaupe}{sampled likelihood function}}}

$$PL({\gamma}) = \prod_{i=1}^n \dfrac{e^{\gamma_{s_i} - \gamma_{s_i^\ast}}}{1+e^{\gamma_{s_i} - \gamma_{s_i^\ast}}} - \dfrac{1}{2 \sigma^2_{\text{sp}}}{\gamma}^T{\gamma} $$

### 3.4.   Estimate the Coefficients of the Spline

\colorbox{pastelyellow}{Exercise 3}: 

\colorbox{pastelyellow}{E3.1}: Let `unit` be $n\times 1$ unit vector. Define `I` combining `unit` and `-unit`.

```{r}
unit <- rep(1, nrow(dat.gam))
I = cbind(unit,-unit)	
```

\colorbox{pastelyellow}{E3.2} Fit the model incorporating a random effect. 

REMARK: default spline's type for `gam` in `mgcv` consists of \textcolor{mauvetaupe}{thin plate regression spline}. Instead, we need to specify that we aim to fit a random effect. 

```{r}
gam_sp.only <- gam(y ~ s(sp, by=I, bs="re") - 1,
    family="binomial"(link = 'logit'),
    method="REML", data=dat.gam)
```

### 3.5.   Interpreting Species Invasiveness Random Effects

\colorbox{darkseagreen}{Demo 9}:
  
```{r}
re.species <- coefficients(gam_sp.only)
names(re.species) <- levels(sp)
```

```{r}
sort(re.species, decreasing = TRUE)[1:5]
```

```{r}
sort(re.species)[1:5]
```

```{r}
# save(gam_sp.only, file="02-Data/02-Gam-Fits/gam_sp.only.RData")
rm(gam_sp.only, sp1, sp2, unit, I)
# save.image("01-Data/01-Inputs/input04.RData")
```

## 4.   Fit a model with all the components included

\colorbox{pastelyellow}{Exercise 4}: 

\colorbox{pastelyellow}{E4.1}: Load the input data \textcolor{persianred}{"input04.RData"}. 

\emph{In the object} \textcolor{persianred}{"input04.RData"} \emph{you can find the case-control dataset including the values for the covariate} \textcolor{cerulean}{Climatic dissimilarity}, \textcolor{cerulean}{Trade},
\textcolor{cerulean}{Distance} \emph{computed for the events and the non-events, plus the object \textcolor{cerulean}{species matrix} tracking levels of species involved. The dataset also includes the values of unique species and regions involved in the system. Furthermore, the dataset contains the numerical codifications for species and regions, referred to as} spec \emph{and} reg, \emph{respectively. You will also find the function} `bspline` \emph{, and the random effects estimated from the gam including just random effects}. 

```{r}
load("01-Data/01-Inputs/input04.RData")
```

\colorbox{pastelyellow}{E4.2}: Fit a model with all the components included. Inspect eventual changes in the interpretation and consider the values of the AIC, to understand which model has a better predictive power.

```{r}
unit <- rep(1, nrow(dat.gam))
stp = dat.gam$year
X = cbind(dat.gam$d1,dat.gam$d2)
I = cbind(unit,-unit)		
```

```{r}
gam_complete <- gam(y ~ dt + 
                      s(stp, by=tr) +
                      s(X, by=I) +
                      s(sp, by=I, bs="re") - 1,
    family="binomial"(link = 'logit'),
    method="REML", data=dat.gam)
```

#### Model Selection

```{r}
load(file="01-Data/02-Gam-Fits/gam_dt.only.RData")
load(file="01-Data/02-Gam-Fits/gam_tr.only.RData")
load(file="01-Data/02-Gam-Fits/gam_d.only.RData")
load(file="01-Data/02-Gam-Fits/gam_sp.only.RData")
```

```{r}
AIC(gam_dt.only)
AIC(gam_tr.only)
AIC(gam_d.only)
AIC(gam_sp.only)
AIC(gam_complete)
```
#### Changes in random effect predictions

```{r}
sort(re.species, decreasing = TRUE)[1:5]
sort(re.species)[1:5]
```

```{r}
re.species_complete <- coefficients(gam_complete)[21:length(coefficients(gam_complete))]
names(re.species_complete) <- levels(sp)
sort(re.species_complete, decreasing = TRUE)[1:5]
sort(re.species_complete)[1:5]
```

```{r}
# save.image("01-Data/03-Output/output.RData")
```
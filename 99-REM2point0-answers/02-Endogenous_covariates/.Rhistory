common.nodes <- unique(l)
if (length(common.nodes) != 0) {
# Iterate over each common node 'a'
for (a in common.nodes) {
# Check if 'a' is the receiver 'r' (reciprocity check)
if (a == r) {
stop_t <- dat.gam$time[t[which(dat.gam[t, 2] == r &
dat.gam[t, 3] == s)]]
stop_t <- max(stop_t)
if (stop_t>=(current-alpha)){
rec_rec <- max(rec_rec,1)
} else {
rec_long <- max(rec_long, 1)
}
rec_id <- max(rec_id, 1)
} else {
# Find the latest time 'a' interacted towards 's'
stop_t <- dat.gam$time[t[which(dat.gam[t, 2] == a &
dat.gam[t, 3] == s)]]
stop_t <- max(stop_t)
# Check if 'r' interacted towards 'a' before 'stop_t'
t2 <- which(dat.gam[prev:max(which(dat.gam$time == stop_t)), 2] == r &
dat.gam[prev:max(which(dat.gam$time == stop_t)), 3] == a)
# If at least one such event is found, set cyclic closure indicator
if (length(t2) > 0) {
if (stop_t>=(current-alpha)){
cyc_rec <- max(cyc_rec,1)
} else {
cyc_long <- max(cyc_long, 1)
}
cyc_id <- max(cyc_id, 1)
} else {
# Check if 'r' interacted towards 'a' before 's' interacted towards 'r'
t3 <- which(dat.gam[1:prev, 2] == r & dat.gam[1:prev, 3] == a)
if (length(t3) > 0) {
if (stop_t>=(current-alpha)){
cyc_rec <- max(cyc_rec,1)
} else {
cyc_long <- max(cyc_long, 1)
}
cyc_id <- max(cyc_id, 1)
}
}
}
}
}
}
# Return the reciprocity and cyclic closure indicators
return_object <- c(rec_rec, rec_long, rec_id, cyc_rec, cyc_long, cyc_id)
names(return_object) <- c("rec_short",
"rec_long",
"rec_id",
"cyc_short",
"cyc_long",
"cyc_id")
return(return_object)
}
#   Frame 1
t(sapply(1:5, function(x) rec_cyc_slt(dat.gam = rem_dat, k=x,
alpha = 4)))
colnames(frame_1) <- c("rec_short",
"rec_long",
"rec_id",
"cyc_short",
"cyc_long",
"cyc_id")
#   Frame 1
frame_1 <- t(sapply(1:5, function(x) rec_cyc_slt(dat.gam = rem_dat, k=x,
alpha = 4)))
colnames(frame_1) <- c("rec_short",
"rec_long",
"rec_id",
"cyc_short",
"cyc_long",
"cyc_id")
frame_1
#   Frame 1
frame <- t(sapply(1:20, function(x) rec_cyc_slt(dat.gam = rem_dat, k=x,
alpha = 4)))
colnames(frame) <- c("rec_short",
"rec_long",
"rec_id",
"cyc_short",
"cyc_long",
"cyc_id")
frame
k=12
dat.gam = rem_dat
alpha = 4
current <- as.numeric(dat.gam[k, 1])
# Determine which column indices to use based on the 'ev' flag
if (ev) {
s <- dat.gam[k, 2]   # 's' is the second column (event sender)
r <- dat.gam[k, 3]   # 'r' is the third column (event receiver)
} else {
s <- dat.gam[k, 4]   # 's' is the fourth column (event sender)
r <- dat.gam[k, 5]   # 'r' is the fifth column (event receiver)
}
ev=TRUE
current <- as.numeric(dat.gam[k, 1])
# Determine which column indices to use based on the 'ev' flag
if (ev) {
s <- dat.gam[k, 2]   # 's' is the second column (event sender)
r <- dat.gam[k, 3]   # 'r' is the third column (event receiver)
} else {
s <- dat.gam[k, 4]   # 's' is the fourth column (event sender)
r <- dat.gam[k, 5]   # 'r' is the fifth column (event receiver)
}
# Check if k is within bounds of dat.gam
if (k < 1 || k > nrow(dat.gam)) {
stop("k is out of bounds.")
}
# If k is 1, there's no history to compare, return (0, 0)
if (k == 1) {
return(c(0, 0, 0, 0, 0, 0))
} else {
# Initialize variables to store reciprocity and cyclic closure indicators
rec_rec <- rec_long <- rec_id <- 0
cyc_rec <- cyc_long <- cyc_id <- 0
# Determine the starting point in the past to begin examining
prev <- which(dat.gam[1:(k-1), 2] == s & dat.gam[1:(k-1), 3] == r)
if (length(prev) > 0) {
prev <- prev[length(prev)] + 1
} else {
prev <- 1
}
# Check if there are third parties interacting towards 's'
t <- which(dat.gam[prev:k, 3] == s)
t <- prev + t - 1
l <- dat.gam[t, 2]
common.nodes <- unique(l)
if (length(common.nodes) != 0) {
# Iterate over each common node 'a'
for (a in common.nodes) {
# Check if 'a' is the receiver 'r' (reciprocity check)
if (a == r) {
stop_t <- dat.gam$time[t[which(dat.gam[t, 2] == r &
dat.gam[t, 3] == s)]]
stop_t <- max(stop_t)
if (stop_t>=(current-alpha)){
rec_rec <- max(rec_rec,1)
} else {
rec_long <- max(rec_long, 1)
}
rec_id <- max(rec_id, 1)
} else {
# Find the latest time 'a' interacted towards 's'
stop_t <- dat.gam$time[t[which(dat.gam[t, 2] == a &
dat.gam[t, 3] == s)]]
stop_t <- max(stop_t)
# Check if 'r' interacted towards 'a' before 'stop_t'
t2 <- which(dat.gam[prev:max(which(dat.gam$time == stop_t)), 2] == r &
dat.gam[prev:max(which(dat.gam$time == stop_t)), 3] == a)
# If at least one such event is found, set cyclic closure indicator
if (length(t2) > 0) {
if (stop_t>=(current-alpha)){
cyc_rec <- max(cyc_rec,1)
} else {
cyc_long <- max(cyc_long, 1)
}
cyc_id <- max(cyc_id, 1)
} else {
# Check if 'r' interacted towards 'a' before 's' interacted towards 'r'
t3 <- which(dat.gam[1:prev, 2] == r & dat.gam[1:prev, 3] == a)
if (length(t3) > 0) {
if (stop_t>=(current-alpha)){
cyc_rec <- max(cyc_rec,1)
} else {
cyc_long <- max(cyc_long, 1)
}
cyc_id <- max(cyc_id, 1)
}
}
}
}
}
}
# Return the reciprocity and cyclic closure indicators
return_object <- c(rec_rec, rec_long, rec_id, cyc_rec, cyc_long, cyc_id)
current <- as.numeric(dat.gam[k, 1])
current
# Determine which column indices to use based on the 'ev' flag
if (ev) {
s <- dat.gam[k, 2]   # 's' is the second column (event sender)
r <- dat.gam[k, 3]   # 'r' is the third column (event receiver)
} else {
s <- dat.gam[k, 4]   # 's' is the fourth column (event sender)
r <- dat.gam[k, 5]   # 'r' is the fifth column (event receiver)
}
# Check if k is within bounds of dat.gam
if (k < 1 || k > nrow(dat.gam)) {
stop("k is out of bounds.")
}
# Initialize variables to store reciprocity and cyclic closure indicators
rec_rec <- rec_long <- rec_id <- 0
cyc_rec <- cyc_long <- cyc_id <- 0
# Determine the starting point in the past to begin examining
prev <- which(dat.gam[1:(k-1), 2] == s & dat.gam[1:(k-1), 3] == r)
if (length(prev) > 0) {
prev <- prev[length(prev)] + 1
} else {
prev <- 1
}
prev
# Check if there are third parties interacting towards 's'
t <- which(dat.gam[prev:k, 3] == s)
t <- prev + t - 1
l <- dat.gam[t, 2]
common.nodes <- unique(l)
common.nodes
a = "C"
# Find the latest time 'a' interacted towards 's'
stop_t <- dat.gam$time[t[which(dat.gam[t, 2] == a &
dat.gam[t, 3] == s)]]
stop_t <- max(stop_t)
stop_t
# Check if 'r' interacted towards 'a' before 'stop_t'
t2 <- which(dat.gam[prev:max(which(dat.gam$time == stop_t)), 2] == r &
dat.gam[prev:max(which(dat.gam$time == stop_t)), 3] == a)
t2
current-alpha
stop_t
rem_dat$time <- as.numeric(rec_cyc_slt(dat.gam = rem_dat, k=x,
alpha = 4))
rem_dat$time <- as.numeric(rem_dat$time)
save.image(file="input02.RData")
load(file="input02.RData")
current <- as.numeric(dat.gam[k, 1])
# Determine which column indices to use based on the 'ev' flag
if (ev) {
s <- dat.gam[k, 2]   # 's' is the second column (event sender)
r <- dat.gam[k, 3]   # 'r' is the third column (event receiver)
} else {
s <- dat.gam[k, 4]   # 's' is the fourth column (event sender)
r <- dat.gam[k, 5]   # 'r' is the fifth column (event receiver)
}
# Check if k is within bounds of dat.gam
if (k < 1 || k > nrow(dat.gam)) {
stop("k is out of bounds.")
}
# Initialize variables to store reciprocity and cyclic closure indicators
rec_rec <- rec_long <- rec_id <- 0
cyc_rec <- cyc_long <- cyc_id <- 0
# Determine the starting point in the past to begin examining
prev <- which(dat.gam[1:(k-1), 2] == s & dat.gam[1:(k-1), 3] == r)
if (length(prev) > 0) {
prev <- prev[length(prev)] + 1
} else {
prev <- 1
}
# Check if there are third parties interacting towards 's'
t <- which(dat.gam[prev:k, 3] == s)
t <- prev + t - 1
l <- dat.gam[t, 2]
common.nodes <- unique(l)
# Find the latest time 'a' interacted towards 's'
stop_t <- dat.gam$time[t[which(dat.gam[t, 2] == a &
dat.gam[t, 3] == s)]]
stop_t <- max(stop_t)
stop_t
# Check if 'r' interacted towards 'a' before 'stop_t'
t2 <- which(dat.gam[prev:max(which(dat.gam$time == stop_t)), 2] == r &
dat.gam[prev:max(which(dat.gam$time == stop_t)), 3] == a)
stop_t>=(current-alpha)
dat.gam$time[t[which(dat.gam[t, 2] == r &
dat.gam[t, 3] == s)]]
dat.gam = rem_dat
# Find the latest time 'a' interacted towards 's'
stop_t <- dat.gam$time[t[which(dat.gam[t, 2] == a &
dat.gam[t, 3] == s)]]
stop_t
rec_cyc_slt <- function(dat.gam, k, alpha, ev=TRUE) {
current <- as.numeric(dat.gam[k, 1])
# Determine which column indices to use based on the 'ev' flag
if (ev) {
s <- dat.gam[k, 2]   # 's' is the second column (event sender)
r <- dat.gam[k, 3]   # 'r' is the third column (event receiver)
} else {
s <- dat.gam[k, 4]   # 's' is the fourth column (event sender)
r <- dat.gam[k, 5]   # 'r' is the fifth column (event receiver)
}
# Check if k is within bounds of dat.gam
if (k < 1 || k > nrow(dat.gam)) {
stop("k is out of bounds.")
}
# If k is 1, there's no history to compare, return (0, 0)
if (k == 1) {
return(c(0, 0, 0, 0, 0, 0))
} else {
# Initialize variables to store reciprocity and cyclic closure indicators
rec_rec <- rec_long <- rec_id <- 0
cyc_rec <- cyc_long <- cyc_id <- 0
# Determine the starting point in the past to begin examining
prev <- which(dat.gam[1:(k-1), 2] == s & dat.gam[1:(k-1), 3] == r)
if (length(prev) > 0) {
prev <- prev[length(prev)] + 1
} else {
prev <- 1
}
# Check if there are third parties interacting towards 's'
t <- which(dat.gam[prev:k, 3] == s)
t <- prev + t - 1
l <- dat.gam[t, 2]
common.nodes <- unique(l)
if (length(common.nodes) != 0) {
# Iterate over each common node 'a'
for (a in common.nodes) {
# Check if 'a' is the receiver 'r' (reciprocity check)
if (a == r) {
stop_t <- dat.gam$time[t[which(dat.gam[t, 2] == r &
dat.gam[t, 3] == s)]]
stop_t <- max(stop_t)
if (stop_t>=(current-alpha)){
rec_rec <- max(rec_rec,1)
} else {
rec_long <- max(rec_long, 1)
}
rec_id <- max(rec_id, 1)
} else {
# Find the latest time 'a' interacted towards 's'
stop_t <- dat.gam$time[t[which(dat.gam[t, 2] == a &
dat.gam[t, 3] == s)]]
stop_t <- max(stop_t)
# Check if 'r' interacted towards 'a' before 'stop_t'
t2 <- which(dat.gam[prev:max(which(dat.gam$time == stop_t)), 2] == r &
dat.gam[prev:max(which(dat.gam$time == stop_t)), 3] == a)
# If at least one such event is found, set cyclic closure indicator
if (length(t2) > 0) {
if (stop_t>=(current-alpha)){
cyc_rec <- max(cyc_rec,1)
} else {
cyc_long <- max(cyc_long, 1)
}
cyc_id <- max(cyc_id, 1)
} else {
# Check if 'r' interacted towards 'a' before 's' interacted towards 'r'
t3 <- which(dat.gam[1:prev, 2] == r & dat.gam[1:prev, 3] == a)
if (length(t3) > 0) {
if (stop_t>=(current-alpha)){
cyc_rec <- max(cyc_rec,1)
} else {
cyc_long <- max(cyc_long, 1)
}
cyc_id <- max(cyc_id, 1)
}
}
}
}
}
}
# Return the reciprocity and cyclic closure indicators
return_object <- c(rec_rec, rec_long, rec_id, cyc_rec, cyc_long, cyc_id)
names(return_object) <- c("rec_short",
"rec_long",
"rec_id",
"cyc_short",
"cyc_long",
"cyc_id")
return(return_object)
}
#   Frame 1
rec_cyc_slt(dat.gam = rem_dat, k=12, alpha = 4)
frame <- t(sapply(1:20, function(x) rec_cyc_slt(dat.gam = rem_dat, k=x,
alpha = 4)))
colnames(frame) <- c("rec_short",
"rec_long",
"rec_id",
"cyc_short",
"cyc_long",
"cyc_id")
frame
#   Frame 1
rec_cyc_slt(dat.gam = rem_dat, k=12, alpha = 2)
frame <- t(sapply(1:20, function(x) rec_cyc_slt(dat.gam = rem_dat, k=x,
alpha = 4)))
colnames(frame) <- c("rec_short",
"rec_long",
"rec_id",
"cyc_short",
"cyc_long",
"cyc_id")
frame
frame <- t(sapply(1:20, function(x) rec_cyc_slt(dat.gam = rem_dat, k=x,
alpha = 2)))
colnames(frame) <- c("rec_short",
"rec_long",
"rec_id",
"cyc_short",
"cyc_long",
"cyc_id")
frame
frame <- t(sapply(1:20, function(x) rec_cyc_slt(dat.gam = rem_dat, k=x,
alpha = 3)))
colnames(frame) <- c("rec_short",
"rec_long",
"rec_id",
"cyc_short",
"cyc_long",
"cyc_id")
frame
frame <- t(sapply(1:20, function(x) rec_cyc_slt(dat.gam = rem_dat, k=x,
alpha = 4)))
colnames(frame) <- c("rec_short",
"rec_long",
"rec_id",
"cyc_short",
"cyc_long",
"cyc_id")
frame
#   Frame 1
frame_1 <- t(sapply(1:20, function(x) rec_cyc_slt(dat.gam = rem_dat, k=x,
alpha = 4)))
colnames(frame_1) <- c("rec_short",
"rec_long",
"rec_id",
"cyc_short",
"cyc_long",
"cyc_id")
frame_1
#   Frame 1
frame_1 <- t(sapply(1:20, function(x) rec_cyc_slt(dat.gam = rem_dat, k=x,
alpha = 4)))
colnames(frame_1) <- c("rec_short",
"rec_long",
"rec_id",
"cyc_short",
"cyc_long",
"cyc_id")
frame_1
#   Frame 1
frame_1 <- t(sapply(1:20, function(x) rec_cyc_slt(dat.gam = rem_dat, k=x,
alpha = 3)))
colnames(frame_1) <- c("rec_short",
"rec_long",
"rec_id",
"cyc_short",
"cyc_long",
"cyc_id")
frame_1
#   Frame 1
frame_1 <- t(sapply(1:20, function(x) transitive_closure_slt(dat.gam = rem_dat, k=x,
alpha = 3)))
colnames(frame_1) <- c("rec_short",
"rec_long",
"rec_id",
"cyc_short",
"cyc_long",
"cyc_id")
#   Frame 1
frame_2 <- t(sapply(1:20, function(x) transitive_closure_slt(dat.gam = rem_dat, k=x,
alpha = 3)))
colnames(frame_2) <- c("trs_short", "trs_long", "trs_id"))
#   Frame 1
frame_2 <- t(sapply(1:20, function(x) transitive_closure_slt(dat.gam = rem_dat, k=x,
alpha = 3)))
colnames(frame_2) <- c("trs_short", "trs_long", "trs_id")
frame_2
#   Frame 3
frame_3 <- t(sapply(1:20, function(x) repetition_slt(dat.gam = rem_dat, k=x,
alpha = 3)))
repetition_slt <- function(dat.gam, k, alpha, ev=TRUE, current=NULL) {
if(is.null(current)){
current <- as.numeric(dat.gam[k, 1])
}
# Determine which column indices to use based on the 'ev' flag
if (ev) {
s <- dat.gam[k, 2]   # 's' is the second column (event sender)
r <- dat.gam[k, 3]   # 'r' is the third column (event receiver)
} else {
s <- dat.gam[k, 4]   # 's' is the fourth column (event sender)
r <- dat.gam[k, 5]   # 'r' is the fifth column (event receiver)
}
# Check if k is within bounds of dat.gam
if (k < 1 || k > nrow(dat.gam)) {
stop("k is out of bounds.")
}
# If k is 1, there's no history to compare, return 0
if (k == 1) {
return(c(0, 0, 0))
} else {
# Initialize variables to store reciprocity and cyclic closure indicators
rep_rec <- rep_long <- rep_id <- 0
# Determine the starting point in the past to begin examining
prev <- which(dat.gam[1:(k-1), 2] == s & dat.gam[1:(k-1), 3] == r)
if (length(prev) > 0) {
stop_t <- max(dat.gam[prev,"time"])
if (stop_t>=(current-alpha)){
rep_rec <- max(rep_rec,1)
} else {
rep_long <- max(rep_long, 1)
}
rep_id <- 1
}
}
return(c(rep_rec, rep_long, rep_id))
}
#   Frame 3
frame_3 <- t(sapply(1:20, function(x) repetition_slt(dat.gam = rem_dat, k=x,
alpha = 3)))
#   Frame 3
frame_3 <- t(sapply(1:20, function(x) repetition_slt(dat.gam = rem_dat, k=x,
alpha = 3)))
colnames(frame_3) <- c("rep_short", "rep_long", "rep_id")
frame_3
load("~/Dropbox/Sunbelt_2024/03-Tutorials/Federica/REMs20/R/02_reshape-output_M_45_060.RData")
View(sample_gam)
setwd("/Users/martina.boschi/Dropbox/Sunbelt_2024/03-Tutorials/FedeandMarti")
dat.gam <- sample_gam
head(dat.gam)
colnames(dat.gam)
save(dat.gam, file="input03.RData")
save(dat.gam, file="input03.RData")
